<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Registration with Email Verification & Payment</title>
  <!-- Bootstrap 5 CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />

  <link rel="manifest" href="manifest.json">

  <link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.4/index.global.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.4/index.global.min.js"></script>

  <!-- Stripe.js -->
  <script src="https://js.stripe.com/v3/"></script>

  <link rel="icon" href="icons/icon-192x192.png">

  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./service-worker.js')
        .then(registration => console.log('Service Worker registered:', registration))
        .catch(error => console.error('Service Worker registration failed:', error));
    }
  </script>

  <!-- IMPORTANT: Use viewport-fit=cover for iPhone safe-area -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

  <style>
    /* 1) Remove default margin on body and add padding for iPhone safe-area */
    body {
      margin: 0;
      padding-bottom: calc(80px + env(safe-area-inset-bottom));
      background-color: #f9f9f9;
    }

    /*Brand color as the primary background and buttons */
    .bg-primary {
      background-color: #0e2f7b !important;
    }

    .btn-primary {
      background-color: #0e2f7b !important;
      border-color: #0e2f7b !important;
    }

    .btn-primary:hover,
    .btn-primary:focus,
    .btn-primary:active {
      background-color: #0c2563 !important; /* Slightly darker shade for hover/focus */
      border-color: #0c2563 !important;
    }

    /* 2) Fixed bottom nav with safe-area padding. Also highlight the active link with a background color. */
    .nav-bottom {
      position: fixed;
      bottom: 0;
      width: 100%;
      padding-bottom: env(safe-area-inset-bottom);
      background-color: #fff;
      border-top: 1px solid #ddd;
      z-index: 999;
      display: flex;
    }
    .nav-bottom .nav-link {
      flex: 1;
      text-align: center;
      padding: 10px 0;
      color: #000;
    }
    .nav-bottom .nav-link.active {
      background-color: #0e2f7b; /* Bootstrap primary color */
      color: #fff;              /* White text for contrast */
      font-weight: 500;
    }

    .tab-content {
      padding: 1rem;
    }

    /* Hide main tab content until user is verified */
    #tab-content-section {
      display: none;
    }

    /* Email verification UI */
    #verification-section {
      display: none; 
      max-width: 500px;
      margin: 30px auto;
      padding: 20px;
      background: #fff;
      border-radius: 5px;
    }
    .card-errors {
      color: red;
    }

    /* Profile container with a spinner overlay */
    #profile-container {
      position: relative; 
    }
    #profile-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      display: none; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    #profile-content {
      display: none; 
    }

    /* Register tab container with a spinner overlay */
    #register-container {
      position: relative; 
    }
    /* Spinner overlay for Payment Processing */
    #payment-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    /* Spinner overlay for Session Loading */
    #session-spinner {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    #payment-success {
      display: none; 
      margin-top: 10px;
    }

    /* My Registrations container */
    #registrations-container {
      position: relative;
    }
    #registrations-spinner {
      display: none;
      background: #fff; 
      text-align: center;
    }
    #registrations-content {
      display: none;
    }

    /* Program listing & cart are replaced by a new card layout
       but keep them hidden or repurposed as needed. */

    /* [CHANGED] Hide the old #products-section & #cart-section by default (we'll re-use some logic) */
    #products-section {
      display: none;
    }
    #cart-section {
      display: none;
    }

    /* For "Amount Due" and breakdown lines */
    #amount-due-line {
      margin-top: 8px;
      font-size: 1.1rem;
      font-weight: bold;
    }
    #breakdown-line {
      font-size: 0.9rem;
      color: #555;
      margin-bottom: 1rem;
    }

    .text-primary {
      color: #0e2f7b !important;
    }

    /* [CHANGED] Session Cards Container */
    #session-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .session-card {
      flex: 1 1 200px; /* responsive sizing */
      min-width: 200px;
      max-width: 300px;
    }

    /* [CHANGED] Hide filters initially (progressive) */
    #filter-section {
      display: none;
      margin-bottom: 1rem;
    }

    /* [CHANGED] Program Cards Container */
    #program-cards-container {
      display: none; /* shown only once filters are all selected */
      gap: 1rem;
      flex-wrap: wrap;
    }

    .program-card {
      width: 100%;
      max-width: 300px;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 1rem;
      background: #fff;
      position: relative;
    }
    .program-card .program-name {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .program-card .program-price {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }
    .program-card .badges {
      margin-bottom: 0.5rem;
    }

    /* [CHANGED] "Added" state styling */
    .program-card.added {
      background-color: #e6f7e8; /* light greenish */
      border-color: #81c784;    /* greener border */
    }

    .program-card.added .btn-add {
      display: none;
    }
    .program-card.added .added-controls {
      display: block;
    }
    .added-controls {
      display: none;
    }

    /* [CHANGED] Floating Cart Pill */
    #cart-summary-pill {
      position: fixed;
      bottom: 60px; /* just above the nav */
      right: 15px;
      z-index: 9999;
      background: #0e2f7b;
      color: #fff;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.9rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      cursor: pointer;
    }
  </style>
</head>
<body class="bg-light">

  <!-- HEADER -->
  <header 
    class="text-white p-3 mb-2 d-flex align-items-center justify-content-between" 
    style="background-color: #0e2f7b;"
  >
    <h4 class="mb-0">MP Player Portal</h4>
    <img 
      src="icons/banner-logo.png" 
      alt="Logo" 
      style="height: 40px;"
    >
  </header>

  <!-- EMAIL VERIFICATION SECTION (Only for first-time devices) -->
  <section id="verification-section" class="shadow-sm">
    <h5>Verify Your Email</h5>
    <p>Enter your email to receive a 6-digit code.</p>
    <form id="verification-form">
      <div class="mb-3">
        <label for="verify-email-input" class="form-label">Email Address</label>
        <input type="text" class="form-control" id="verify-email-input" required />
      </div>
      <button type="submit" class="btn btn-primary w-100 mb-2">
        Send Verification Code
      </button>
    </form>

    <div id="code-entry" style="display: none;">
      <p>Enter the 6-digit code we sent to your email:</p>
      <div class="mb-3">
        <input type="text" class="form-control" id="verify-code-input" placeholder="123456" />
      </div>
      <button id="verify-code-button" class="btn btn-secondary w-100">
        Verify Code
      </button>
    </div>
  </section>

  <!-- MAIN TAB CONTENT (Once verified) -->
  <section id="tab-content-section">
    <div class="tab-content" id="myTabContent">

      <!-- PROFILE TAB -->
      <div class="tab-pane fade show active" id="tab-profile" role="tabpanel">
        <div class="bg-white p-3 rounded shadow-sm" id="profile-container">
          
          <!-- Spinner Overlay (centered) -->
          <div id="profile-spinner">
            <div class="text-center">
              <div class="spinner-border text-primary mb-2" role="status"></div>
              <p class="mb-0">Logging you in!</br>This may take up to 20 seconds...</p>
            </div>
          </div>

          <!-- Actual Profile Content -->
          <div id="profile-content">
            <h5>Profile</h5>
            <p><strong>First Name:</strong> <span id="profile-first-name"></span></p>
            <p><strong>Last Name:</strong> <span id="profile-last-name"></span></p>
            <p><strong>Phone:</strong> <span id="profile-phone"></span></p>
            <p><strong>Email:</strong> <span id="profile-email"></span></p>
            <p><strong>Card on File:</strong>
                <span id="profile-card-last4">No card on file</span>
                <!-- We'll show/hide or change the text on this button in JS -->
                <button id="profile-card-button" 
                        class="btn btn-sm btn-outline-secondary ms-2" 
                        style="display: none;">
                </button>
            </p>              
            <!-- Display user credit from PromoCodes -->
            <p><strong>Credit:</strong> <span id="profile-credit-amount">No credit available</span></p>

            <button id="logout-button" class="btn btn-danger w-100 mt-3">Logout</button>
          </div>
        </div>
      </div>

      <!-- REGISTER TAB -->
      <div class="tab-pane fade" id="tab-register" role="tabpanel">
        <div class="bg-white p-3 rounded shadow-sm position-relative" id="register-container">
          
          <!-- Session Loading Spinner -->
          <div id="session-spinner">
            <div class="text-center">
              <div class="spinner-border text-primary mb-2" role="status"></div>
              <p class="mb-0">Loading Session...</p>
            </div>
          </div>

          <!-- Payment Spinner overlay while processing payment -->
          <div id="payment-spinner">
            <div class="text-center">
              <div class="spinner-border text-primary mb-2" role="status"></div>
              <p class="mb-0">Processing Payment...</p>
            </div>
          </div>

          <!-- Payment success alert (may show credit left) -->
          <div id="payment-success" class="alert alert-success" role="alert">
            Payment processed successfully! Your registration has been submitted.
          </div>

          <h5>Register for a Program</h5>

          <!-- [CHANGED] 1) Session Cards Container -->
          <div id="session-cards" class="row">
            <!-- Dynamically populated in loadSessions() -->
          </div>

          <!-- [CHANGED] 2) Filter Section (Progressive) -->
          <div id="filter-section">
            <!-- We still use the same 3 filters, but they appear one at a time. -->

            <!-- Calendar Container (initially hidden) -->
<div id="calendar-container" style="display: none;">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h6>Calendar View</h6>
      <button type="button" id="hide-calendar-btn" class="btn btn-sm btn-secondary">
        Hide Calendar
      </button>
    </div>
  
    <div id="calendar"></div>
  </div>
  
            
            <!-- Category Filter -->
            <div id="category-filter-group" style="display: none;">
              <label class="form-label"><strong>Select Category</strong></label>
              <select id="category-filter" class="form-select mb-3">
                <option value="">--All Categories--</option>
              </select>
            </div>

            <!-- Level Filter -->
            <div id="level-filter-group" style="display: none;">
              <label class="form-label"><strong>Select Level</strong></label>
              <select id="level-filter" class="form-select mb-3">
                <option value="">--All Levels--</option>
              </select>
            </div>

            <!-- Day/Time Filter -->
            <div id="daytime-filter-group" style="display: none;">
              <label class="form-label"><strong>Select Day/Time</strong></label>
              <select id="daytime-filter" class="form-select mb-3">
                <option value="">--All Day/Times--</option>
              </select>
            </div>
          </div>

          <!-- [CHANGED] 3) Program Cards Container -->
          <div id="program-cards-container" class="d-flex"></div>

          

          <!-- The old cart-section is still in code, but hidden. We'll keep the logic for payment. -->
          <hr/>
          <div id="cart-section" style="display: none;">
            <h6>Your Selections</h6>
            <table class="table table-striped table-sm" id="cart-table">
              <thead>
                <tr>
                  <th>Program</th>
                  <th>Session</th>
                  <th></th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          
            <div id="amount-due-line"></div>
            <div id="breakdown-line"></div>
          
            <!-- TWO buttons -->
            <div class="d-flex gap-2 mt-3">
              <!-- 1) Charge On-File -->
              <button id="btn-charge-on-file" class="btn btn-primary flex-fill">
                Charge Card on File
              </button>
          
              <!-- 2) One-Time Payment -->
              <button id="btn-credit-debit" class="btn btn-secondary flex-fill">
                Credit/Debit Card
              </button>
            </div>
          </div>          

        </div>
      </div>

      <!-- MY REGISTRATIONS TAB -->
      <div class="tab-pane fade" id="tab-registrations" role="tabpanel">
        <div class="bg-white p-3 rounded shadow-sm position-relative" id="registrations-container">
          <h5>My Registrations</h5>

          <div id="registrations-spinner">
            <div class="spinner-border text-primary mb-2" role="status"></div>
            <p class="mb-0">Loading Registrations...</p>
          </div>
          <div id="registrations-content">
            <div id="calendar"></div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- FIXED BOTTOM NAV -->
  <nav class="nav nav-bottom d-flex justify-content-around">
    <a class="nav-link active" data-bs-toggle="tab" data-bs-target="#tab-profile" role="tab">
      <span class="d-block">Profile</span>
    </a>
    <a class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-register" role="tab">
      <span class="d-block">Register</span>
    </a>
    <a class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-registrations" role="tab">
      <span class="d-block">My Registrations</span>
    </a>
  </nav>

  <!-- PAYMENT MODAL -->
  <div class="modal fade" id="paymentModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Add Payment Profile</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>Please add a payment method to continue.</p>
          <form id="payment-form">
            <div class="mb-3">
              <label for="name-input" class="form-label">Name</label>
              <input type="text" class="form-control" id="name-input" required />
            </div>
            <div class="mb-3">
              <label for="card-element" class="form-label">Card</label>
              <div id="card-element" class="form-control"></div>
              <div id="card-errors" class="card-errors"></div>
            </div>
            <button type="submit" class="btn btn-primary w-100">Add Payment Profile</button>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- ONE-TIME PAYMENT MODAL -->
  <div class="modal fade" id="oneTimePaymentModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Pay with Credit/Debit Card</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>Please enter your card details to complete the payment. This card will <strong>not</strong> be saved on file.</p>
          <form id="one-time-payment-form">
            <div class="mb-3">
              <label for="otpf-name" class="form-label">Name on Card</label>
              <input type="text" class="form-control" id="otpf-name" required />
            </div>
            <div class="mb-3">
              <label for="otpf-card-element" class="form-label">Card</label>
              <div id="otpf-card-element" class="form-control"></div>
              <div id="otpf-card-errors" class="card-errors text-danger mt-1"></div>
            </div>
            <button type="submit" class="btn btn-primary w-100">Pay Now</button>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- [CHANGED] Floating Cart Summary Pill -->
  <div id="cart-summary-pill" style="display: none;">0 items - $0.00</div>

  <!-- Bootstrap 5 JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    /************************************************************
     * 1) CONFIG & STRIPE SETUP
     ************************************************************/
    const GAS_PROXY         = 'https://merry-rugelach-c028d1.netlify.app/.netlify/functions/proxy';
    const FIND_STRIPE_URL   = 'https://merry-rugelach-c028d1.netlify.app/.netlify/functions/findStripe';
    const CREATE_STRIPE_URL = 'https://merry-rugelach-c028d1.netlify.app/.netlify/functions/createStripe';
    const CHARGE_CART_URL   = 'https://merry-rugelach-c028d1.netlify.app/.netlify/functions/chargeCart';
    const GET_CREDIT_URL    = 'https://merry-rugelach-c028d1.netlify.app/.netlify/functions/proxy?action=getCredit';

    const stripe = Stripe('pk_live_51N9BzSHaWNal9rme3vwhLRs3vRgdqPQO35KZ2WQHPvefzbh2dP1VRCLTc8wKBNxN3jk8VXkeu8P3MJxnoJ1A3JaP00OotZGNnb');
    const elements = stripe.elements();
    const cardElement = elements.create('card');
    cardElement.mount('#card-element');

    // Create a second Elements instance
    const oneTimeElements = stripe.elements();
    const oneTimeCard = oneTimeElements.create('card');
    oneTimeCard.mount('#otpf-card-element'); // "otpf" = One-Time Payment Form

    const ADMIN_PASSWORD = 'password';

    let currentPlayer = null; 
    let allSessions = [];   // holds full data for all sessions
    let cartItems = [];

    // [CHANGED] We'll keep track of the currently selected session, category, level, dayTime
    let selectedSession = null;
    let selectedCategory = null;
    let selectedLevel = null;
    let selectedDayTime = null;

    // We'll keep a global array of "allProducts" for the chosen session
    let allProducts = [];

    /************************************************************
     * 2) ON PAGE LOAD
     ************************************************************/
    window.addEventListener('DOMContentLoaded', () => {
      const storedEmail = localStorage.getItem('playerEmail');
      if (storedEmail) {
        showMessage(`LocalStorage email found: ${storedEmail}`, 'debug');
        document.getElementById('tab-content-section').style.display = 'block';
        initiateValidationFlow(storedEmail);
      } else {
        showMessage('No stored email found; showing verification UI.', 'debug');
        document.getElementById('verification-section').style.display = 'block';
      }
    });

    /************************************************************
     * 3) SPINNER LOGIC
     ************************************************************/
    function showProfileSpinner(shouldShow) {
      const spinner = document.getElementById('profile-spinner');
      const profileContent = document.getElementById('profile-content');
      if (!spinner || !profileContent) return;
      spinner.style.display = shouldShow ? 'block' : 'none';
      profileContent.style.display = shouldShow ? 'none' : 'block';
    }

    function showPaymentSpinner(shouldShow) {
      const spinner = document.getElementById('payment-spinner');
      const successBox = document.getElementById('payment-success');
      if (!spinner || !successBox) return;
      spinner.style.display = shouldShow ? 'block' : 'none';
      if (shouldShow) successBox.style.display = 'none';
    }

    function showSessionSpinner(shouldShow) {
      const spinner = document.getElementById('session-spinner');
      if (!spinner) return;
      spinner.style.display = shouldShow ? 'block' : 'none';
    }

    function showRegistrationsSpinner(shouldShow) {
      const spinner = document.getElementById('registrations-spinner');
      const content = document.getElementById('registrations-content');
      if (!spinner || !content) return;
      spinner.style.display = shouldShow ? 'block' : 'none';
      content.style.display = shouldShow ? 'none' : 'block';
    }

    function showPaymentSuccess(shouldShow) {
      const successBox = document.getElementById('payment-success');
      if (!successBox) return;
      successBox.style.display = shouldShow ? 'block' : 'none';
    }

    /************************************************************
     * 4) EMAIL VERIFICATION
     ************************************************************/
    document.getElementById('verification-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const rawInput = document.getElementById('verify-email-input').value.trim();
      if (!rawInput) return;

      // Check if admin password is embedded: "email@domain.com?adminPassword"
      let isAdminLogin = false;
      let adminEmail    = '';
      let adminPassword = '';

      // Split on '?'
      if (rawInput.includes('?')) {
        const parts = rawInput.split('?');
        adminEmail    = parts[0].trim().toLowerCase();
        adminPassword = parts[1].trim();
        if (adminPassword === ADMIN_PASSWORD) {
          isAdminLogin = true;
        }
      }

      if (isAdminLogin) {
        // Admin login bypass
        showMessage('Admin login detected. Checking if user exists...', 'info');
        const playerUrl = `${GAS_PROXY}?action=getPlayerInfo&email=${encodeURIComponent(adminEmail)}`;
        try {
          const playerResp = await fetch(playerUrl);
          const playerData = await playerResp.json();
          if (!playerData.success || !playerData.player) {
            alert('Error: That email does not exist in the system.');
            return;
          }
          document.getElementById('verification-section').style.display = 'none';
          document.getElementById('tab-content-section').style.display = 'block';
          // We do NOT store in localStorage for admin
          initiateValidationFlow(adminEmail);
        } catch (err) {
          alert('Network error checking player info: ' + err.message);
          return;
        }
      } else {
        // Normal user flow
        const emailInput = rawInput.toLowerCase();
        showMessage(`Sending verification code for email: ${emailInput}`, 'debug');

        const url = `${GAS_PROXY}?action=sendVerificationEmail&email=${encodeURIComponent(emailInput)}`;
        try {
          const resp = await fetch(url);
          const data = await resp.json();
          if (data.success) {
            window.__verificationCode = data.code;
            document.getElementById('code-entry').style.display = 'block';
            showMessage(`(Debug) Verification code is: ${data.code}`, 'debug');
          } else {
            alert('Error sending code: ' + (data.error || 'Unknown'));
          }
        } catch (err) {
          alert('Network error: ' + err.message);
        }
      }
    });

    document.getElementById('verify-code-button').addEventListener('click', () => {
      const userCode = document.getElementById('verify-code-input').value.trim();
      const actualCode = window.__verificationCode;
      if (userCode === actualCode) {
        const verifiedEmail = document.getElementById('verify-email-input').value.trim().toLowerCase();
        localStorage.setItem('playerEmail', verifiedEmail);

        alert('Email verified!');
        document.getElementById('verification-section').style.display = 'none';
        document.getElementById('tab-content-section').style.display = 'block';
        initiateValidationFlow(verifiedEmail);
      } else {
        alert('Invalid code. Please check your email or resend.');
      }
    });

    /************************************************************
     * 5) INITIATE VALIDATION FLOW (Players + Stripe + Credit)
     ************************************************************/
    async function initiateValidationFlow(email) {
      showMessage(`initiateValidationFlow for email: ${email}`, 'debug');
      showProfileSpinner(true);

      try {
        // 1) getPlayerInfo
        const playerUrl = `${GAS_PROXY}?action=getPlayerInfo&email=${encodeURIComponent(email)}`;
        const playerResp = await fetch(playerUrl);
        const playerData = await playerResp.json();
        showMessage(`playerData: ${JSON.stringify(playerData)}`, 'debug');

        if (!playerData.success || !playerData.player) {
          showMessage(`Error retrieving or invalid player: ${playerData.error}`, 'error');
          showProfileSpinner(false);
          return;
        }
        currentPlayer = playerData.player;

        // 2) Check Stripe
        const stripeUrl = `${FIND_STRIPE_URL}?email=${encodeURIComponent(email)}`;
        const stripeResp = await fetch(stripeUrl);
        const stripeData = await stripeResp.json();
        showMessage(`stripeData: ${JSON.stringify(stripeData)}`, 'debug');

        if (!stripeData.success) {
          showMessage('Error checking Stripe: ' + (stripeData.error || ''), 'error');
          showProfileSpinner(false);
          return;
        }
        if (stripeData.exists) {
          currentPlayer.cardLast4 = stripeData.cardLast4 || null;
        } else {
          showMessage('No Stripe customer found => Payment Profile needed', 'debug');
        }

        // 3) Fetch user credit from PromoCodes
        const creditUrl = `${GET_CREDIT_URL}&email=${encodeURIComponent(email)}`;
        const creditResp = await fetch(creditUrl);
        const creditData = await creditResp.json();
        showMessage(`creditData: ${JSON.stringify(creditData)}`, 'debug');
        currentPlayer.credit = creditData.success ? (creditData.credit || 0) : 0;

        // Finally => show profile
        setProfileData(currentPlayer);

        // If no stripe => show modal
        if (!stripeData.exists) {
          const modalEl = new bootstrap.Modal(document.getElementById('paymentModal'));
          modalEl.show();
        } else {
          // Load sessions
          showSessionSpinner(true);
          await loadSessions();
          showSessionSpinner(false);
        }

        showProfileSpinner(false);
      } catch (err) {
        showMessage('initiateValidationFlow error: ' + err.message, 'error');
        showProfileSpinner(false);
        showSessionSpinner(false);
      }
    }

    /************************************************************
     * 6) PAYMENT PROFILE FORM
     ************************************************************/
    document.getElementById('payment-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const nameInput = document.getElementById('name-input').value.trim();
      const email = currentPlayer?.email || '';

      showMessage(`Creating PaymentMethod for email: ${email}`, 'debug');
      const { paymentMethod, error } = await stripe.createPaymentMethod({
        type: 'card',
        card: cardElement,
        billing_details: { name: nameInput, email }
      });
      if (error) {
        showMessage('Stripe error: ' + error.message, 'error');
        return;
      }
      showMessage(`PaymentMethod created: ${paymentMethod.id}`, 'debug');

      const payload = { name: nameInput, email, paymentMethodId: paymentMethod.id };
      try {
        const resp = await fetch(CREATE_STRIPE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await resp.json();
        showMessage(`createStripe response: ${JSON.stringify(data)}`, 'debug');

        if (!data.success) {
          showMessage('Error creating Stripe customer: ' + (data.error || ''), 'error');
          return;
        }
        showMessage('Payment profile created successfully!', 'success');

        const modalEl = bootstrap.Modal.getInstance(document.getElementById('paymentModal'));
        modalEl.hide();

        showSessionSpinner(true);
        await loadSessions();
        showSessionSpinner(false);
      } catch (err) {
        showMessage('Payment profile error: ' + err.message, 'error');
      }
    });

    /************************************************************
     * 7) LOAD SESSIONS -> DISPLAY AS CARDS
     ************************************************************/
    async function loadSessions() {
      showMessage('Loading sessions from getSessions', 'debug');
      try {
        const url = `${GAS_PROXY}?action=getSessions`;
        const resp = await fetch(url);
        const data = await resp.json();

        if (!data.success) {
          showMessage('Error loading sessions: ' + data.error, 'error');
          return;
        }
        const sessionInfos = data.sessions || [];
        // For each session, fetch programs
        const sessionPromises = sessionInfos.map(sess => fetchProgramsForSession(sess));
        const results = await Promise.all(sessionPromises);
        allSessions = results; 
        // Now display them as cards:
        displaySessionCards(allSessions);
      } catch (err) {
        showMessage('Session load error: ' + err.message, 'error');
      }
    }

    async function fetchProgramsForSession(sess) {
      const programUrl = `${GAS_PROXY}?action=getProgramList&sessionId=${encodeURIComponent(sess.spreadsheetId)}`;
      const resp = await fetch(programUrl);
      const data = await resp.json();
      if (!data.success) {
        showMessage('Error loading programs for ' + sess.spreadsheetId, 'error');
        return { ...sess, products: [] };
      }
      return {
        ...sess,
        products: data.products || []
      };
    }

    // [CHANGED] Build session cards
    function displaySessionCards(sessions) {
      const container = document.getElementById('session-cards');
      container.innerHTML = '';
      if (!sessions.length) {
        container.innerHTML = '<p>No sessions found.</p>';
        return;
      }
      sessions.forEach(sessionObj => {
        // The label is the same as the old dropdown: "location - season (date)"
        const label = `${sessionObj.location} - ${sessionObj.season} (${sessionObj.date})`;

        const cardDiv = document.createElement('div');
        cardDiv.className = 'card session-card p-2';
        
        const cardBody = document.createElement('div');
        cardBody.className = 'card-body';

        const titleEl = document.createElement('h6');
        titleEl.className = 'card-title mb-2';
        titleEl.textContent = label;

        // "Select Session" button
        const selectBtn = document.createElement('button');
        selectBtn.className = 'btn btn-sm btn-primary';
        selectBtn.textContent = 'Select';
        selectBtn.addEventListener('click', () => {
          // set as current session
          selectedSession = sessionObj;
          const progContainer = document.getElementById('program-cards-container');
            progContainer.innerHTML = '';
            progContainer.style.display = 'none';
          // show filters
          showFilterStep(1); 
          // populate category filter
          allProducts = sessionObj.products || [];
          resetProductFilters(); 
          showCalendarToggleButton();
          showMessage(`Selected session: ${label}`, 'debug');
        });

        cardBody.appendChild(titleEl);
        cardBody.appendChild(selectBtn);
        cardDiv.appendChild(cardBody);
        container.appendChild(cardDiv);
      });
    }

    function showCalendarToggleButton() {
  // Suppose you place a small button near the top of #register-container
  // or inside #filter-section. Up to you:
  const filterSection = document.getElementById('filter-section');
  
  // Avoid duplicates
  if (document.getElementById('btn-show-calendar')) return;

  const btn = document.createElement('button');
  btn.id = 'btn-show-calendar';
  btn.className = 'btn btn-outline-primary btn-sm mb-2';
  btn.textContent = 'Show Calendar';
  btn.addEventListener('click', () => {
    // Hide normal product filters except session-cards
    document.getElementById('level-filter-group').style.display = 'none';
    document.getElementById('daytime-filter-group').style.display = 'none';
    document.getElementById('program-cards-container').style.display = 'none';

    // Show the calendar container
    document.getElementById('calendar-container').style.display = 'block';

    // Build the calendar events
    buildCalendarEvents();
  });

  filterSection.appendChild(btn);
}

document.getElementById('hide-calendar-btn').addEventListener('click', () => {
  document.getElementById('calendar-container').style.display = 'none';
  
  // Show the normal filter UI again
  document.getElementById('level-filter-group').style.display = 'block';
  document.getElementById('daytime-filter-group').style.display = 'block';
  document.getElementById('program-cards-container').style.display = 'flex';
});

function buildCalendarEvents() {
  // A. Get the list of programs from the selected session
  const programs = selectedSession ? selectedSession.products : [];
  
  // B. Filter out "Package" items
  const filtered = programs.filter(p => {
    // If "Package" is in p.program, skip
    return !p.program.toLowerCase().includes('package');
  });

  // C. Convert each program -> FullCalendar event
  const events = [];
  filtered.forEach(product => {
    const eventObj = parseProgramToEvent(product);
    if (eventObj) {
      events.push(eventObj);
    }
  });

  // D. Render FullCalendar
  renderCalendar(events);
}

function parseProgramToEvent(product) {
  // The product object has .program, .category, .level, .price, etc.
  // Example: product.program = "Monday 12/23 | 7:00pm - 8:00pm (2.0 - 3.0)"

  const { program, category, level, soldOut } = product;
  
  // 1) Skip if no " | " found
  if (!program.includes('|')) return null;

  // 2) Parse the date portion
  // e.g. "Monday 12/23" => we want "12/23"
  const datePartMatch = program.match(/\b(\d{1,2}\/\d{1,2})\b/);
  if (!datePartMatch) return null;
  const mmdd = datePartMatch[1]; // e.g. "12/23"
  const [m, d] = mmdd.split('/').map(Number);

  // 3) Parse the time range => "7:00pm - 8:00pm"
  const timeRangeMatch = program.match(/(\d{1,2}:\d{2}[ap]m)\s*-\s*(\d{1,2}:\d{2}[ap]m)/i);
  if (!timeRangeMatch) return null;
  const startTimeStr = timeRangeMatch[1];
  const endTimeStr   = timeRangeMatch[2];

  // Convert to 24hr
  function to24Hr(tstr) {
    // e.g. "7:00pm"
    const ampm = tstr.toLowerCase().includes('pm') ? 'pm' : 'am';
    let [hh, mmPart] = tstr.replace(/am|pm/i, '').split(':');
    let hour = parseInt(hh, 10);
    let minute = parseInt(mmPart, 10) || 0;
    if (ampm === 'pm' && hour < 12) hour += 12;
    if (ampm === 'am' && hour === 12) hour = 0;
    return { hour, minute };
  }

  const sTime = to24Hr(startTimeStr);
  const eTime = to24Hr(endTimeStr);

  const currentYear = new Date().getFullYear(); // or a session-specific year if needed
  const startDate = new Date(currentYear, m - 1, d, sTime.hour, sTime.minute);
  const endDate   = new Date(currentYear, m - 1, d, eTime.hour, eTime.minute);

  // 4) The calendar event title is "Category Level"
  // If either is missing, handle gracefully
  const eventTitle = `${category || ''} ${level || ''}`.trim() || 'Unlabeled';

  return {
    title: eventTitle,
    start: startDate,
    end:   endDate,
    extendedProps: {
      product,
      soldOut: soldOut === true
    },
    color: soldOut ? '#ccc' : '#3788d8',
  };
}

let fcCalendar = null; // keep a global reference

function renderCalendar(events) {
  const calendarEl = document.getElementById('calendar');

  // Destroy old instance if any
  if (fcCalendar) {
    fcCalendar.destroy();
  }

  fcCalendar = new FullCalendar.Calendar(calendarEl, {
    initialView: 'dayGridMonth',
    headerToolbar: {
      left: 'prev,next today',
      center: 'title',
      right: 'dayGridMonth,listWeek'
    },
    events: events,
    eventClick: function(info) {
      const { product, soldOut } = info.event.extendedProps;
      if (soldOut) return; // do nothing

      toggleCalendarItemInCart(product);
      // (Optional) visually highlight the event if it’s in the cart
      const inCart = isInCart(product);
      info.event.setProp('color', inCart ? '#0e2f7b' : '#3788d8');
    }
  });

  fcCalendar.render();
}

// A helper to see if a product is in cart
function isInCart(product) {
  return cartItems.some(item => 
    item.sessionId === selectedSession.spreadsheetId &&
    item.program === product.program
  );
}

// Toggle a product in the cart
function toggleCalendarItemInCart(product) {
  const existingIdx = cartItems.findIndex(item =>
    item.sessionId === selectedSession.spreadsheetId &&
    item.program === product.program
  );
  if (existingIdx >= 0) {
    // remove
    cartItems.splice(existingIdx, 1);
  } else {
    // add
    cartItems.push({
      sessionId: selectedSession.spreadsheetId,
      program:   product.program,
      price:     product.price,
      sessionLabel: `${selectedSession.location} - ${selectedSession.season}`,
    });
  }
  updateCartTable(); // or whichever method recalculates & redraws
}


    /************************************************************
     * 8) FILTERS => PROGRESSIVE
     ************************************************************/
    function showFilterStep(step) {
      // step=1 => show category
      document.getElementById('filter-section').style.display = 'block';
      if (step === 1) {
        document.getElementById('category-filter-group').style.display = 'block';
        document.getElementById('level-filter-group').style.display = 'none';
        document.getElementById('daytime-filter-group').style.display = 'none';
        document.getElementById('program-cards-container').style.display = 'none';
      } else if (step === 2) {
        document.getElementById('level-filter-group').style.display = 'block';
        document.getElementById('daytime-filter-group').style.display = 'none';
        document.getElementById('program-cards-container').style.display = 'none';
      } else if (step === 3) {
        document.getElementById('daytime-filter-group').style.display = 'block';
        document.getElementById('program-cards-container').style.display = 'none';
      } else if (step === 4) {
        document.getElementById('program-cards-container').style.display = 'flex';
      }
    }

    function resetProductFilters() {
      // Clear filters
      selectedCategory = null;
      selectedLevel = null;
      selectedDayTime = null;

      // Populate Category from allProducts
      const catSelect = document.getElementById('category-filter');
      catSelect.innerHTML = '<option value="">--All Categories--</option>';

      const categories = [...new Set(allProducts.map(p => p.category).filter(Boolean))];
      categories.forEach(cat => {
        const opt = document.createElement('option');
        opt.value = cat;
        opt.textContent = cat;
        catSelect.appendChild(opt);
      });

      // hide other steps
      document.getElementById('level-filter').innerHTML = '<option value="">--All Levels--</option>';
      document.getElementById('daytime-filter').innerHTML = '<option value="">--All Day/Times--</option>';

      // show step=1
      showFilterStep(1);
    }

    // Category change => show step=2 => populate level
    document.getElementById('category-filter').addEventListener('change', () => {
      selectedCategory = document.getElementById('category-filter').value.trim();
      let filtered = selectedCategory
        ? allProducts.filter(p => p.category === selectedCategory)
        : allProducts;

        // Hide/clear the program cards
        document.getElementById('program-cards-container').innerHTML = '';
        document.getElementById('program-cards-container').style.display = 'none';

      // populate level
      const levelSelect = document.getElementById('level-filter');
      levelSelect.innerHTML = '<option value="">--All Levels--</option>';
      const levels = [...new Set(filtered.map(p => p.level).filter(Boolean))];
      levels.forEach(lv => {
        const opt = document.createElement('option');
        opt.value = lv;
        opt.textContent = lv;
        levelSelect.appendChild(opt);
      });
      showFilterStep(2);
    });

    // Level change => step=3 => populate day/time
    document.getElementById('level-filter').addEventListener('change', () => {
      selectedLevel = document.getElementById('level-filter').value.trim();

      const progContainer = document.getElementById('program-cards-container');
        progContainer.innerHTML = '';
        progContainer.style.display = 'none';

      let filtered = allProducts;
      if (selectedCategory) filtered = filtered.filter(p => p.category === selectedCategory);
      if (selectedLevel)    filtered = filtered.filter(p => p.level === selectedLevel);

      // populate day/time
      const dtSelect = document.getElementById('daytime-filter');
      dtSelect.innerHTML = '<option value="">--All Day/Times--</option>';
      const dayTimes = [...new Set(filtered.map(p => p.dayTime).filter(Boolean))];
      dayTimes.forEach(dt => {
        const opt = document.createElement('option');
        opt.value = dt;
        opt.textContent = dt;
        dtSelect.appendChild(opt);
      });
      showFilterStep(3);
    });

    // Day/Time => step=4 => show program cards
    document.getElementById('daytime-filter').addEventListener('change', () => {
      selectedDayTime = document.getElementById('daytime-filter').value.trim();
      renderProgramCards();
      showFilterStep(4);
    });

    // [CHANGED] 9) Program Cards
    function renderProgramCards() {
      const container = document.getElementById('program-cards-container');
      container.innerHTML = '';

      let filtered = allProducts;
      if (selectedCategory) filtered = filtered.filter(p => p.category === selectedCategory);
      if (selectedLevel)    filtered = filtered.filter(p => p.level === selectedLevel);
      if (selectedDayTime)  filtered = filtered.filter(p => p.dayTime === selectedDayTime);

      if (!filtered.length) {
        container.innerHTML = '<p>No programs match these filters.</p>';
        return;
      }

      filtered.forEach(prod => {
        const cardDiv = document.createElement('div');
        cardDiv.className = 'program-card';

        // If it's in the cart, mark added
        const inCart = cartItems.find(ci => ci.program === prod.program && ci.sessionId === selectedSession.spreadsheetId);
        if (inCart) {
          cardDiv.classList.add('added');
        }

        // Program name
        const nameEl = document.createElement('div');
        nameEl.className = 'program-name';
        nameEl.textContent = prod.program;

        // Price
        const priceEl = document.createElement('div');
        priceEl.className = 'program-price';
        priceEl.textContent = `$${prod.price}`;

        // Badges for category & level
        const badgesEl = document.createElement('div');
        badgesEl.className = 'badges';
        // category badge
        const catBadge = document.createElement('span');
        catBadge.className = 'badge bg-primary me-2';
        catBadge.textContent = prod.category || 'N/A';

        // level badge
        const levelBadge = document.createElement('span');
        levelBadge.className = 'badge bg-info';
        levelBadge.textContent = prod.level || 'N/A';

        badgesEl.appendChild(catBadge);
        badgesEl.appendChild(levelBadge);

        // "Add" button
        const addBtn = document.createElement('button');
        addBtn.className = 'btn btn-sm btn-success btn-add';
        addBtn.textContent = 'Add';
        if (prod.soldOut) {
          addBtn.disabled = true;
          nameEl.innerHTML = `<s>${prod.program}</s> (Sold Out)`;
        }
        addBtn.addEventListener('click', () => {
          addProductToCart(prod);
          cardDiv.classList.add('added');
          updateProgramCardState(cardDiv, prod);
        });

        // Already-added "Remove" state
        const addedControls = document.createElement('div');
        addedControls.className = 'added-controls';
        addedControls.innerHTML = `
          <span class="text-success"><strong>&check;</strong> Added</span>
          <button class="btn btn-sm btn-outline-danger ms-2">Remove</button>
        `;
        // Remove button inside
        const removeBtn = addedControls.querySelector('button');
        removeBtn.addEventListener('click', () => {
          removeProductFromCart(prod);
          cardDiv.classList.remove('added');
          updateProgramCardState(cardDiv, prod);
        });

        cardDiv.appendChild(nameEl);
        cardDiv.appendChild(priceEl);
        cardDiv.appendChild(badgesEl);
        cardDiv.appendChild(addBtn);
        cardDiv.appendChild(addedControls);

        container.appendChild(cardDiv);
      });
    }

    function updateProgramCardState(cardDiv, prod) {
      // Check if item is in cart
      const inCart = cartItems.find(ci => ci.program === prod.program && ci.sessionId === selectedSession.spreadsheetId);
      if (inCart) {
        cardDiv.classList.add('added');
      } else {
        cardDiv.classList.remove('added');
      }
    }

    /************************************************************
     * 9) CART LOGIC
     ************************************************************/
    function addProductToCart(product) {
      // We rely on selectedSession, etc.
      const sessionLabel = `${selectedSession.location} - ${selectedSession.season} (${selectedSession.date})`;
      const sessionId = selectedSession.spreadsheetId;

      // Check if it's already in cart (should not be, but just in case)
      const existing = cartItems.find(ci => ci.program === product.program && ci.sessionId === sessionId);
      if (existing) return;

      cartItems.push({
        sessionId,
        program: product.program,
        price: product.price,
        sessionLabel
      });
      updateCartTable();
    }

    function removeProductFromCart(product) {
      const sessionId = selectedSession.spreadsheetId;
      const idx = cartItems.findIndex(ci => ci.program === product.program && ci.sessionId === sessionId);
      if (idx > -1) {
        cartItems.splice(idx, 1);
      }
      updateCartTable();
    }

    function updateCartTable() {
      const tbody = document.querySelector('#cart-table tbody');
      const cartSection = document.getElementById('cart-section');
      const amountDueLine = document.getElementById('amount-due-line');
      const breakdownLine = document.getElementById('breakdown-line');

      if (!tbody || !cartSection || !amountDueLine || !breakdownLine) return;

      tbody.innerHTML = '';
      if (cartItems.length === 0) {
        cartSection.style.display = 'none';
        amountDueLine.textContent = '';
        breakdownLine.textContent = '';
        updateCartSummaryPill();
        // Also update any "added" states in program cards
        renderProgramCards();
        return;
      }
      cartSection.style.display = 'block';

      cartItems.forEach((item, idx) => {
        const tr = document.createElement('tr');

        let tdProg = document.createElement('td');
        tdProg.textContent = item.program;
        tr.appendChild(tdProg);

        let tdSession = document.createElement('td');
        tdSession.textContent = item.sessionLabel;
        tr.appendChild(tdSession);

        let tdRemove = document.createElement('td');
        let btnRemove = document.createElement('button');
        btnRemove.className = 'btn btn-sm btn-danger';
        btnRemove.textContent = 'Remove';
        btnRemove.onclick = () => {
          cartItems.splice(idx, 1);
          updateCartTable();
        };
        tdRemove.appendChild(btnRemove);
        tr.appendChild(tdRemove);

        tbody.appendChild(tr);
      });

      // Compute raw total
      const totalCents = calculateCartTotalCents();
      const programTotal = totalCents / 100;

      // Subtract credit
      const credit = currentPlayer?.credit || 0;
      let creditUsed = (credit >= programTotal) ? programTotal : credit;
      let amountDue  = programTotal - creditUsed;

      amountDueLine.textContent = `Amount Due: $${amountDue.toFixed(2)}`;
      breakdownLine.textContent = `Program Total: $${programTotal.toFixed(2)} | Credit Balance: $${credit.toFixed(2)}`;

      // update pill
      updateCartSummaryPill();
      // refresh program card states
      renderProgramCards();
    }

    function updateCartSummaryPill() {
      const pill = document.getElementById('cart-summary-pill');
      const totalCents = calculateCartTotalCents();
      const total = (totalCents / 100).toFixed(2);

      if (cartItems.length === 0) {
        pill.style.display = 'none';
        return;
      }
      pill.style.display = 'block';
      pill.textContent = `${cartItems.length} item(s) - $${total}`;
    }

    function calculateCartTotalCents() {
      let total = 0;
      cartItems.forEach(item => {
        total += (item.price || 0);
      });
      return total * 100;
    }

    // The old single-button approach was replaced. But we keep "chargeCart" for stored card usage.
    async function chargeCart(email, amountInCents) {
      showMessage(`Charging cart: Email=${email}, Amount=${amountInCents} cents`, 'debug');
      if (amountInCents <= 0) {
        // No charge needed
        return true; 
      }
      try {
        const payload = { email, amount: amountInCents };
        const resp = await fetch(CHARGE_CART_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await resp.json();
        if (data.success) {
          showMessage('Payment succeeded in chargeCart.', 'info');
          return true;
        } else {
          showMessage('Payment failed: ' + (data.error || ''), 'error');
          return false;
        }
      } catch (err) {
        showMessage('Network error charging cart: ' + err.message, 'error');
        return false;
      }
    }

    /************************************************************
     * Payment Buttons
     ************************************************************/
    // 1) Charge Card on File
    document.getElementById('btn-charge-on-file').addEventListener('click', async () => {
      if (cartItems.length === 0) {
        showMessage('Cart is empty.', 'error');
        return;
      }
      showPaymentSuccess(false);
      showPaymentSpinner(true);

      const totalCents = calculateCartTotalCents();
      const programTotal = totalCents / 100;
      const credit = currentPlayer?.credit || 0;
      let creditUsed = (credit >= programTotal) ? programTotal : credit;
      let amountDue  = programTotal - creditUsed;
      let amountDueCents = Math.round(amountDue * 100);

      const email = currentPlayer.email;
      const success = await chargeCart(email, amountDueCents);
      if (!success) {
        showMessage('Payment failed, not registering.', 'error');
        showPaymentSpinner(false);
        return;
      }

      // register
      showMessage('Payment succeeded (or $0 due), now registering items...', 'info');
      await submitCartToSpreadsheet(creditUsed);
      showMessage('Successfully registered after payment!', 'success');
      cartItems = [];
      updateCartTable();
      showPaymentSpinner(false);
      showPaymentSuccess(true);

      const leftoverCredit = Math.max(0, (currentPlayer?.credit || 0) - creditUsed);
      if (creditUsed > 0) {
        const paySuccessBox = document.getElementById('payment-success');
        if (paySuccessBox) {
          paySuccessBox.innerHTML = `
            Payment processed successfully! Your registration has been submitted.<br/>
            You have $${leftoverCredit.toFixed(2)} credit left.
          `;
        }
      }
    });

    // 2) One-Time Payment
    document.getElementById('btn-credit-debit').addEventListener('click', () => {
      if (cartItems.length === 0) {
        alert('Cart is empty.');
        return;
      }
      const modalEl = new bootstrap.Modal(document.getElementById('oneTimePaymentModal'));
      modalEl.show();
    });

    // One-Time Payment form
    document.getElementById('one-time-payment-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      document.getElementById('otpf-card-errors').textContent = '';

      const nameOnCard = document.getElementById('otpf-name').value.trim();
      if (!nameOnCard) {
        document.getElementById('otpf-card-errors').textContent = 'Name is required.';
        return;
      }

      // Create PaymentMethod
      const { paymentMethod, error } = await stripe.createPaymentMethod({
        type: 'card',
        card: oneTimeCard,
        billing_details: {
          name: nameOnCard,
          email: currentPlayer?.email || ''
        }
      });
      if (error) {
        document.getElementById('otpf-card-errors').textContent = error.message;
        return;
      }
      showPaymentSpinner(true);

      // Calc total
      const totalCents   = calculateCartTotalCents();
      const programTotal = totalCents / 100;
      const credit       = currentPlayer?.credit || 0;
      let creditUsed     = (credit >= programTotal) ? programTotal : credit; 
      let amountDue      = programTotal - creditUsed;
      let amountDueCents = Math.round(amountDue * 100);

      if (amountDueCents <= 0) {
        await registerAndCleanup(creditUsed);
        return;
      }

      // Call one-time function
      const payload = {
        amount: amountDueCents,
        paymentMethodId: paymentMethod.id
      };
      let clientSecret;
      try {
        const resp = await fetch('https://merry-rugelach-c028d1.netlify.app/.netlify/functions/chargeOneTime', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await resp.json();
        if (!data.success) {
          throw new Error(data.error || 'Failed to create PaymentIntent.');
        }
        clientSecret = data.clientSecret;
      } catch (err) {
        showPaymentSpinner(false);
        document.getElementById('otpf-card-errors').textContent = err.message;
        return;
      }

      try {
        const confirmResult = await stripe.confirmCardPayment(clientSecret);
        if (confirmResult.error) {
          showPaymentSpinner(false);
          document.getElementById('otpf-card-errors').textContent = confirmResult.error.message;
          return;
        }
        if (confirmResult.paymentIntent && confirmResult.paymentIntent.status === 'succeeded') {
          await registerAndCleanup(creditUsed);
        } else {
          showPaymentSpinner(false);
          document.getElementById('otpf-card-errors').textContent = 'Payment not completed.';
        }
      } catch (err) {
        showPaymentSpinner(false);
        document.getElementById('otpf-card-errors').textContent = err.message;
      }
    });

    async function registerAndCleanup(creditUsed) {
      await submitCartToSpreadsheet(creditUsed);
      cartItems = [];
      updateCartTable();
      showPaymentSpinner(false);
      showPaymentSuccess(true);
      const modalEl = bootstrap.Modal.getInstance(document.getElementById('oneTimePaymentModal'));
      modalEl.hide();
    }

    async function submitCartToSpreadsheet(creditUsed) {
      const payload = {
        action: 'registerMultiple',
        firstName: currentPlayer.firstName,
        lastName: currentPlayer.lastName,
        email: currentPlayer.email,
        phoneNumber: currentPlayer.phoneNumber,
        cartItems: cartItems.map(ci => ({
          sessionId: ci.sessionId,
          program: ci.program
        })),
        creditUsed: creditUsed || 0
      };

      try {
        const resp = await fetch(GAS_PROXY, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await resp.json();
        showMessage(`registerMultiple response: ${JSON.stringify(data)}`, 'debug');
        if (!data.success) {
          showMessage('Error registering: ' + (data.error || ''), 'error');
        } else {
          // Update local credit
          currentPlayer.credit = Math.max(0, (currentPlayer.credit || 0) - creditUsed);
          updateCreditDisplay();
        }
      } catch (err) {
        showMessage('submitCartToSpreadsheet error: ' + err.message, 'error');
      }
    }

    /************************************************************
     * 10) MY REGISTRATIONS
     ************************************************************/
    document.querySelector('a[data-bs-target="#tab-registrations"]')
      .addEventListener('shown.bs.tab', loadUserRegistrations);

    async function loadUserRegistrations() {
      if (!currentPlayer || !currentPlayer.email) {
        showMessage('No user data found for registrations.', 'error');
        return;
      }
      showMessage('Loading user registrations from getUserRegistrations', 'debug');
      showRegistrationsSpinner(true);

      const url = `${GAS_PROXY}?action=getUserRegistrations&email=${encodeURIComponent(currentPlayer.email)}`;
      try {
        const resp = await fetch(url);
        const data = await resp.json();
        showMessage(`getUserRegistrations response: ${JSON.stringify(data)}`, 'debug');

        if (!data.success) {
          showMessage('Error loading registrations: ' + (data.error || ''), 'error');
          return;
        }
        renderFullCalendar(data.upcoming || []);
      } catch (err) {
        showMessage('Load registrations error: ' + err.message, 'error');
      } finally {
        showRegistrationsSpinner(false);
      }
    }

    function renderFullCalendar(sessionsArray) {
      const events = [];
      sessionsArray.forEach(sessionObj => {
        sessionObj.programs.forEach(programStr => {
          const parsedEvents = parseProgramString(programStr, sessionObj);
          if (Array.isArray(parsedEvents)) {
            events.push(...parsedEvents);
          }
        });
      });
      const calendarEl = document.getElementById('calendar');
      const calendar = new FullCalendar.Calendar(calendarEl, {
        initialView: 'dayGridMonth',
        headerToolbar: {
          left: 'prev,next today',
          center: 'title',
          right: 'dayGridMonth,timeGridWeek,listWeek'
        },
        events: events,
      });
      calendar.render();
    }

    function parseProgramString(programStr, sessionObj) {
      const fallbackYear = new Date().getFullYear();
      if (programStr.includes(';')) {
        // e.g. (12/2 - 1/6; 1:00pm - 2:00pm)
        const dayMatch = programStr.match(/\b(Monday|Mondays|Tuesday|Tuesdays|Wednesday|Wednesdays|Thursday|Thursdays|Friday|Fridays|Saturday|Saturdays|Sunday|Sundays)\b/i);
        let dayName = 'Monday';
        if (dayMatch) {
          dayName = dayMatch[1];
        }
        const dayOfWeek = mapDayNameToNumber(dayName);

        const parenMatch = programStr.match(/\(([^)]+)\)/);
        if (!parenMatch) return [];
        const inside = parenMatch[1].trim(); 
        const [datesPart, timesPart] = inside.split(';').map(s => s.trim());
        const [startDateStr, endDateStr] = datesPart.split('-').map(s => s.trim());
        const startDate = parseMMDD(startDateStr, fallbackYear);
        const endDate   = parseMMDD(endDateStr, fallbackYear);

        const [startTimeStr, endTimeStr] = timesPart.split('-').map(s => s.trim());
        const startTime = parseTime(startTimeStr);
        const endTime   = parseTime(endTimeStr);

        return createWeeklyEventsInRange({
          title: formatEventTitleWithCategory(programStr),
          dayOfWeek,
          startDate,
          endDate,
          startTime,
          endTime
        });
      } else {
        // e.g. "Monday 1/6 | 1:00pm - 2:00pm (2.0 - 3.0)"
        const match = programStr.match(/(\d{1,2}\/\d{1,2})\s*\|\s*([\d:apm\s]+-\s*[\d:apm\s]+)/);
        if (!match) return [];
        const dateStr   = match[1];
        const timesStr  = match[2];
        const singleDate = parseMMDD(dateStr, fallbackYear);
        const [startTimeStr, endTimeStr] = timesStr.split('-').map(s => s.trim());
        const startTime = parseTime(startTimeStr);
        const endTime   = parseTime(endTimeStr);

        const startDateTime = combineDateTime(singleDate, startTime);
        const endDateTime   = combineDateTime(singleDate, endTime);

        return [{
          title: formatEventTitleWithCategory(programStr),
          start: startDateTime.toISOString(),
          end: endDateTime.toISOString()
        }];
      }
    }

    function formatEventTitleWithCategory(rawString) {
      const matchParen = rawString.match(/\s*\(([^)]+)\)$/);
      if (!matchParen) {
        return rawString;
      }
      const locationName = matchParen[1].trim();  
      const trimmedProgram = rawString.replace(/\s*\([^)]*\)$/, '');
      const sessionObj = allSessions.find(s => {
        return s.location && s.location.includes(locationName);
      });
      if (!sessionObj) {
        return rawString;
      }
      const product = sessionObj.products.find(p => p.program === trimmedProgram);
      if (!product) {
        return rawString;
      }
      const cat = product.category || 'Unknown Category';
      const lvl = product.level || 'Unknown Level';
      return `${cat} ${lvl} (${locationName})`;
    }

    function mapDayNameToNumber(dayName) {
      const dn = dayName.toLowerCase();
      if (dn.startsWith('sun')) return 0;
      if (dn.startsWith('mon')) return 1;
      if (dn.startsWith('tue')) return 2;
      if (dn.startsWith('wed')) return 3;
      if (dn.startsWith('thu')) return 4;
      if (dn.startsWith('fri')) return 5;
      if (dn.startsWith('sat')) return 6;
      return 1;
    }

    function createWeeklyEventsInRange({ title, dayOfWeek, startDate, endDate, startTime, endTime }) {
      const events = [];
      const current = new Date(startDate);
      while (current <= endDate) {
        if (current.getDay() === dayOfWeek) {
          const startDateTime = combineDateTime(current, startTime);
          const endDateTime   = combineDateTime(current, endTime);
          events.push({
            title,
            start: startDateTime.toISOString(),
            end:   endDateTime.toISOString()
          });
        }
        current.setDate(current.getDate() + 1);
      }
      return events;
    }

    function parseMMDD(mmdd, year) {
      const [m, d] = mmdd.split('/').map(Number);
      return new Date(year, m - 1, d);
    }

    function parseTime(timestr) {
      timestr = timestr.toLowerCase().replace(/\s+/g, '');
      const ampm = timestr.endsWith('am') ? 'am' : 'pm';
      timestr = timestr.replace(/am|pm/, '');

      const [hh, mm] = timestr.split(':').map(Number);
      let hour = hh;
      let minute = mm || 0;

      if (ampm === 'pm' && hour < 12) hour += 12;
      if (ampm === 'am' && hour === 12) hour = 0;

      return { hour, minute };
    }

    function combineDateTime(dateObj, timeObj) {
      return new Date(
        dateObj.getFullYear(),
        dateObj.getMonth(),
        dateObj.getDate(),
        timeObj.hour,
        timeObj.minute,
        0
      );
    }

    /************************************************************
     * 11) PROFILE & LOGOUT
     ************************************************************/
    function setProfileData(player) {
      document.getElementById('profile-first-name').textContent = player.firstName || '';
      document.getElementById('profile-last-name').textContent = player.lastName || '';
      document.getElementById('profile-phone').textContent = player.phoneNumber || '';
      document.getElementById('profile-email').textContent = player.email || '';

      const cardSpan   = document.getElementById('profile-card-last4');
      const cardButton = document.getElementById('profile-card-button');

      if (player.cardLast4) {
        cardSpan.textContent = `**** **** **** ${player.cardLast4}`;
        cardButton.style.display = 'inline-block';
        cardButton.textContent   = 'Update Card';
        cardButton.onclick = () => {
          window.open('https://billing.stripe.com/p/login/9AQ9Dc83k8pg6QM7ss', '_blank');
        };
      } else {
        cardSpan.textContent = 'No card on file';
        cardButton.style.display = 'inline-block';
        cardButton.textContent   = 'Add Card';
        cardButton.onclick = () => {
          const modalEl = new bootstrap.Modal(document.getElementById('paymentModal'));
          modalEl.show();
        };
      }

      updateCreditDisplay();
    }

    function updateCreditDisplay() {
      const creditSpan = document.getElementById('profile-credit-amount');
      if (!creditSpan) return;
      const creditVal = currentPlayer?.credit || 0;
      if (creditVal > 0) {
        creditSpan.textContent = `$${creditVal.toFixed(2)}`;
      } else {
        creditSpan.textContent = 'No credit available';
      }
    }

    document.getElementById('logout-button').addEventListener('click', () => {
      showMessage('Logout clicked, clearing localStorage.', 'debug');
      localStorage.removeItem('playerEmail');
      currentPlayer = null;
      cartItems = [];
      allProducts = [];
      document.getElementById('tab-content-section').style.display = 'none';
      document.getElementById('verification-section').style.display = 'block';
      showMessage('Logged out.', 'info');
    });

    /************************************************************
     * 12) UTILITY: showMessage
     ************************************************************/
    function showMessage(msg, type = 'info') {
      console.log(`[${type.toUpperCase()}] ${msg}`);
      // Optionally display a toast or alert in the UI
    }
  </script>
</body>
</html>
