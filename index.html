<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" name="theme-color" content="#0e2f7b" />
  <title>Montclair Pickleball Player Portal</title>
  <!-- Bootstrap 5 CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />

  <link rel="manifest" href="manifest.json">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">


  <link href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.4/index.global.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.4/index.global.min.js"></script>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>

  <!-- Stripe.js -->
  <script src="https://js.stripe.com/v3/"></script>

  <link rel="icon" href="icons/icon-192x192.png">

  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./service-worker.js')
        .then(registration => console.log('Service Worker registered:', registration))
        .catch(error => console.error('Service Worker registration failed:', error));
    }
  </script>

  <!-- IMPORTANT: Use viewport-fit=cover for iPhone safe-area -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

  <style>
    /* 1) Remove default margin on body and add padding for iPhone safe-area */
    body {
      margin: 0;
      padding-bottom: calc(80px + env(safe-area-inset-bottom));
      background-color: #f9f9f9;
    }

    /*Brand color as the primary background and buttons */
    .bg-primary {
      background-color: #0e2f7b !important;
    }

    .btn-primary {
      background-color: #0e2f7b !important;
      border-color: #0e2f7b !important;
    }

    .btn-primary:hover,
    .btn-primary:focus,
    .btn-primary:active {
      background-color: #0c2563 !important; /* Slightly darker shade for hover/focus */
      border-color: #0c2563 !important;
    }

    .btn-xs {
      padding: 0.2rem 0.4rem;  /* Adjust as needed */
      font-size: 0.65rem;      /* Smaller font size */
      line-height: 1;
      border-radius: 0.2rem;   /* Optional: adjust to match your badge style */
    }

    /* 2) Fixed bottom nav with safe-area padding. Also highlight the active link with a background color. */
    .nav-bottom {
      position: fixed;
      bottom: 0;
      width: 100%;
      padding-bottom: env(safe-area-inset-bottom);
      background-color: #fff;
      border-top: 1px solid #ddd;
      z-index: 1001;  /* Increase this to be higher than loading container */
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .nav-bottom .nav-link {
      flex: 1;
      text-align: center;
      padding: 10px 0;
      color: #000;
      cursor: pointer;
    }
    .nav-bottom .nav-link.active {
      background-color: #0e2f7b; /* Bootstrap primary color */
      color: #fff;              /* White text for contrast */
      font-weight: 500;
    }

    .nav-bottom .nav-profile {
    flex: 0 0 auto;       /* let it shrink to fit icon content */
    width: 50px;          /* pick a smaller width */
    text-align: center;
    padding: 6px 0;       /* less vertical padding */
    font-size: 1.1rem;    /* adjust icon size as you like */
    }

    .nav-bottom .nav-forum {
    flex: 0 0 auto;
    width: 50px;
    text-align: center;
    padding: 6px 0;
    font-size: 1.2rem;
    }

    .tab-content {
      padding: 1rem;
    }

    /* Hide main tab content until user is verified */
    #tab-content-section {
      display: none;
    }

    /* Email verification UI */
    #verification-section {
      display: none; 
      max-width: 500px;
      margin: 30px auto;
      padding: 20px;
      background: #fff;
      border-radius: 5px;
    }
    .card-errors {
      color: red;
    }

    /* Profile container with a spinner overlay */
    #profile-container {
      position: relative; 
    }
    #profile-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      display: none; 
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    #profile-content {
      display: none; 
    }

    .session-card.selected-session {
    border: 2px solid green; 
    background-color: #e6f7e8; /* a light greenish background to match your existing style */
    transform: scale(1);
    opacity: 1;
    }


    /* Register tab container with a spinner overlay */
    #register-container {
      position: relative; 
    }
    /* Spinner overlay for Payment Processing */
    #payment-spinner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    .overlay {
      background: transparent; 
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 9998;
      display: none;
      pointer-events: all;
    }

    body.modal-open {
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
    }

    /* Spinner overlay for Session Loading */
    #session-spinner {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    #payment-success {
      display: none; 
      margin-top: 10px;
    }

    /* My Registrations container */
    #registrations-container {
      position: relative;
    }
    #registrations-spinner {
      display: none;
      background: #fff; 
      text-align: center;
    }
    #registrations-content {
      display: none;
    }

    /* Program listing & cart are replaced by a new card layout
       but keep them hidden or repurposed as needed. */

    /* [CHANGED] Hide the old #products-section & #cart-section by default (we'll re-use some logic) */
    #products-section {
      display: none;
    }
    #cart-section {
      display: none;
    }

    /* For "Amount Due" and breakdown lines */
    #amount-due-line {
      margin-top: 8px;
      font-size: 1.1rem;
      font-weight: bold;
    }
    #breakdown-line {
      font-size: 0.9rem;
      color: #555;
      margin-bottom: 1rem;
    }

    .text-primary {
      color: #0e2f7b !important;
    }

    /* [CHANGED] Session Cards Container */
    #session-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .session-card {
      flex: 1 1 200px; /* responsive sizing */
      min-width: 200px;
      max-width: 300px;
      transition: transform 0.3s, opacity 0.3s;
    }

    .session-card.non-selected-session {
      transform: scale(0.9);
      opacity: 0.7;
    }

    @media (max-width: 576px) {
  .session-card .card-body {
    padding: 0.75rem;
    font-size: 0.9rem;
  }
  .session-card h6 {
    font-size: 1rem;
  }
}

    /* [CHANGED] Hide filters initially (progressive) */
    #filter-section {
      display: none;
      margin-bottom: 1rem;
    }

    /* [CHANGED] Program Cards Container */
    #program-cards-container {
      display: none; /* shown only once filters are all selected */
      gap: 1rem;
      flex-wrap: wrap;
    }

    .badges .badge {
    margin-bottom: 0.25rem;  /* small spacing between badges */
    margin-right: 0.25rem

    }


    .program-card {
      width: 100%;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 1rem;
      background: #fff;
      position: relative;
      margin-bottom: 1rem;
    }

    /* Program card header styling */
    .program-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.5rem;
    }

    /* Add media query for mobile devices */
    @media (max-width: 768px) {
      .program-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }

      .program-header .badges {
        margin-top: 0.25rem;
      }

      .program-name {
        width: 100%;
      }
    }

    .program-card .program-name {
      font-weight: 600;
      margin: 0;
      flex-grow: 1;
    }

    .program-card .badges {
      display: flex;
      gap: 0.25rem;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    @media (max-width: 768px) {
      .program-card .badges {
        justify-content: flex-start;
        width: 100%;
      }
    }

    .program-card .program-price {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }

    .badges .badge {
      margin-bottom: 0;
      margin-right: 0.25rem;
    }

    /* [CHANGED] "Added" state styling */
    .program-card.added {
      background-color: #e6f7e8; /* light greenish */
      border-color: #81c784;    /* greener border */
    }

    .program-card.added .btn-add {
      display: none;
    }
    .program-card.added .added-controls {
      display: block;
    }
    .added-controls {
      display: none;
    }


    /* [CHANGED] Floating Cart Pill */
    #cart-summary-pill {
      position: fixed;
      bottom: 80px; /* just above the nav */
      right: 15px;
      z-index: 9999;
      background: #0e2f7b;
      color: #fff;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.9rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      cursor: pointer;
    }

    .selected-list-event {
  background-color: #c3e6cb !important; /* a pale green */
}

/* fullCalendar turn off hover effect */
.fc-list-table:hover,
.fc-list-table:hover td {
  background-color: transparent !important;
  color: inherit !important;
}

/* Inactive state: mimic btn-outline-primary */
.fc-button.fc-button-primary {
  color: #ffc107;              /* Primary text color */
  background-color: transparent; /* Transparent background */
  border: 1px solid #ffc107;     /* Primary border */
  border-radius: 0.25rem;        /* Bootstrap border radius */
  transition: background-color 0.2s, color 0.2s;
}

/* Hover effect for inactive buttons */
.fc-button.fc-button-primary:hover {
  color: #fff;
  background-color: #ffc107;
}

.fc .fc-button-primary:not(:disabled).fc-button-active, .fc .fc-button-primary:not(:disabled):active {
  color: black;
  background-color: #ffc107;
  border-color: #ffc107;
}

/* Toolbar Styles */
.fc .fc-toolbar {
  background-color: #0e2f7b;
  padding: 10px;
  border-radius: 0.25rem;
  margin-bottom: 1rem;
  border: none;
}

.fc .fc-toolbar-title {
  color: #fff;
  font-size: 1.5rem;
  font-weight: 600;
}

.fc.fc-media-screen.fc-direction-ltr.fc-theme-standard {
  border: 2px solid #0e2f7b; /* Use your brand color or any color you prefer */
  padding: 5px;              /* Optional: adds some spacing inside the border */
  border-radius: 5px;        /* Optional: gives rounded corners */
}

/* Original CSS for Event List

.fc-list-event-time::before {
  content: "\2610";
  font-size: 1.8em;
  color: #0e2f7b; 
  display: inline-block;
  width: 1.5em;
  text-align: center;
}

.selected-list-event .fc-list-event-time::before {
  content: "\2611"; 
  color: #28a745; 
}

.fc-unselectable .fc-list-event-time::before {
  content: "";
}


.sold-out .fc-list-event-time::before {
  content: "";
}

*/


/* Desktop Default Plus/Check Icon Styles */
.fc-list-event-time::before {
  content: "\2610";
  font-size: 1.8em;
  color: #0e2f7b;
  display: inline-block;
  width: 1.5em;
  text-align: center;
}

.selected-list-event .fc-list-event-time::before {
  content: "\2611";
  color: #28a745;
}

.sold-out .fc-list-event-time::before {
  content: "";
}

.listPackageBtn {
  color: #0e2f7b;
  font-size: 1.0em;
  text-decoration: underline;
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
}

/* Mobile Optimized Card View */
.fc-list-event {
    position: relative;
    display: flex;
    flex-direction: column;
    background: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    /* Extra bottom padding to accommodate the button */
    padding: 10px 15px 40px 15px;
    margin: 8px 0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    font-size: 0.85em;
    line-height: 1.3;
  }

  /* Hide the graphic element on mobile */
  .fc-list-event-graphic {
    display: none !important;
  }

  /* Remove any default table cell styling */
  .fc-list-event td {
    display: block;
    border: none;
    padding: 0;
    margin: 0;
  }

  /* Stack the event time at the top */
  .fc-list-event-time {
    margin-bottom: 4px;
  }

  /* Stack the event title next */
  .fc-list-event-title {
    margin-bottom: 4px;
  }

  /* Adjust the icon size for mobile */
  .fc-list-event-time::before {
    font-size: 1.4em;
    width: 1.3em;
  }

/* Updated CSS for the underlined link */
.listPackageBtn {
    position: absolute;
    bottom: 10px;
    right: 15px;
  }

/* Override table header styling for day header cards */
    th[id^="fc-dom-"] {
    display: block;
    padding: 0;
    border: none;
  }
  
  /* Card styling for the day header container */
  .fc-list-day-cushion {
    display: block;
    background: #f8f8f8; /* Light background for the header card */
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 10px 15px;
    margin: 8px 0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    text-align: center;
  }
  
  /* Stacking and styling the day text */
  .fc-list-day-text {
    display: block;
    font-weight: bold;
    margin-bottom: 4px;
  }
  
  /* Stacking and styling the side text (full date) */
  .fc-list-day-side-text {
    display: block;
    font-size: 0.85em;
    color: #666;
  }

.arrow {
  display: inline-block;
  transition: transform 0.2s ease;
}

a[data-bs-toggle="collapse"][aria-expanded="true"] .arrow {
  transform: rotate(180deg);
}

a[data-bs-toggle="collapse"][aria-expanded="false"] .arrow {
  transform: rotate(0deg);
}

/* Add this to the style section */
.nav-link .loading-indicator {
  display: none;
  width: 8px;
  height: 8px;
  background-color: #ffc107;
  border-radius: 50%;
  position: absolute;
  top: 5px;
  right: 5px;
}

.nav-link.loading .loading-indicator {
  display: block;
}

#register-tab-spinner {
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  background: rgba(255, 255, 255, 0.9);
  padding: 20px;
  border-radius: 8px;
  z-index: 1000;
}

#register-tab-error {
  display: none;
  text-align: center;
  margin: 20px;
}

.loading-container {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(248, 249, 250, 0.95);
  backdrop-filter: blur(5px);
  border-radius: 12px;
  z-index: 1000;  /* Keep this below nav-bottom */
  box-shadow: 0 8px 32px rgba(14, 47, 123, 0.15);
}

.loading-content {
  text-align: center;
  padding: 2rem;
  border-radius: 12px;
  background: transparent;
  width: 100%;
  max-width: 400px;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.loading-title {
  color: #0e2f7b;
  font-size: 1.5rem;
  margin-bottom: 2rem;
  font-weight: 500;
}

.loading-subtitle {
  color: #666;
  margin-top: 1rem;
  font-size: 1rem;
}

.loading-dots {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin: 1.5rem 0;
}

.dot {
  width: 12px;
  height: 12px;
  background: #0e2f7b;
  border-radius: 50%;
  animation: pulse 1.5s infinite;
}

.dot:nth-child(2) {
  animation-delay: 0.2s;
}

.dot:nth-child(3) {
  animation-delay: 0.4s;
}

@keyframes pulse {
  0%, 100% {
    transform: scale(0.8);
    opacity: 0.5;
  }
  50% {
    transform: scale(1.2);
    opacity: 1;
  }
}

.pickleball-icon {
  height: 40px;  /* Match header logo height */
  margin-bottom: 1rem;
  animation: bounce 2s infinite;
}

.pickleball-icon img {
  height: 100%;
  width: auto;
}

@keyframes bounce {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-10px);
  }
}

/* Update the register tab spinner */
#register-tab-spinner {
  display: none;
}

#register-tab-error {
  display: none;
  text-align: center;
  background: white;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 8px 32px rgba(14, 47, 123, 0.1);
  margin: 2rem auto;
  max-width: 400px;
}

#register-tab-error .btn {
  margin-top: 1rem;
}

header.text-white {
  background-color: #0e2f7b;
  z-index: 1001;  /* Match nav-bottom z-index */
  position: relative;  /* Needed for z-index to work */
}

/* Add to style section */
header {
  position: relative;
  z-index: 1001;
  background-color: #0e2f7b;
}

.mini-dialogue {
  position: relative;
  background: #ffb347;
  color: #fff;
  border-radius: 10px;
  padding: 10px 18px;
  font-size: 0.95rem;
  width: fit-content;
  min-width: 220px;
  max-width: 320px;
  margin-top: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.10);
  animation: pulseOrange 1.5s infinite;
  z-index: 2;
  text-align: center;
}
.mini-dialogue-arrow {
  position: absolute;
  top: -12px;
  left: 50%;
  transform: translateX(-50%);
  width: 0;
  height: 0;
  border-left: 12px solid transparent;
  border-right: 12px solid transparent;
  border-bottom: 12px solid #ffb347;
}
@keyframes pulseOrange {
  0%, 100% { box-shadow: 0 0 0 0 rgba(255,179,71,0.5); }
  50% { box-shadow: 0 0 0 8px rgba(255,179,71,0.15); }
}

.mini-dialogue.subtle-dialogue {
  background: #ffe1b3;
  color: #7a5a00;
  border-radius: 8px;
  padding: 7px 14px;
  font-size: 0.88rem;
  min-width: 180px;
  max-width: 260px;
  margin-top: 32px;
  box-shadow: 0 1px 4px rgba(255,179,71,0.10);
  animation: pulseOrangeSubtle 2.2s infinite;
  opacity: 0.92;
}
.mini-dialogue.subtle-dialogue .mini-dialogue-arrow {
  border-bottom: 10px solid #ffe1b3;
  top: -10px;
}
@keyframes pulseOrangeSubtle {
  0%, 100% { box-shadow: 0 0 0 0 rgba(255,179,71,0.18); }
  50% { box-shadow: 0 0 0 6px rgba(255,179,71,0.08); }
}

/* Add these styles in the <style> section */

/* Date group styling */
.date-group {
  background: white;
  border-radius: 12px;
  padding: 1.5rem;
  margin-bottom: 2rem;
  box-shadow: 0 2px 8px rgba(14, 47, 123, 0.08);
  width: 100%;
}

.date-group-header {
  display: flex;
  align-items: center;
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 2px solid #f0f0f0;
  width: 100%;
}

.date-group-header h5 {
  margin: 0;
  color: #0e2f7b;
  font-weight: 600;
}

.date-count-badge {
  margin-left: auto;
  background: #e8eef9;
  color: #0e2f7b;
  padding: 0.25rem 0.75rem;
  border-radius: 20px;
  font-size: 0.9rem;
  font-weight: 500;
}

/* Program cards within date group */
.program-cards-row {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;  /* Reduced from 1rem */
  width: 100%;
}

.program-card {
  border: 1px solid #e0e0e0;
  transition: all 0.2s ease;
  height: 100%;
  margin-bottom: 0.5rem;  /* Reduced from 1rem */
}

.program-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(14, 47, 123, 0.12);
}

.program-card.added {
  border-color: #28a745;
  background-color: #f8fff9;
}

/* Filter section enhancements */
#filter-section {
  background: white;
  padding: 1.5rem;
  border-radius: 12px;
  margin-bottom: 2rem;
  box-shadow: 0 2px 8px rgba(14, 47, 123, 0.08);
}

.filter-group {
  margin-bottom: 1rem;
}

.filter-group h6 {
  color: #0e2f7b;
  margin-bottom: 1rem;
  font-weight: 600;
}

.checkbox-group {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
}

.form-check {
  background: #f8f9fa;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  margin: 0;
  transition: all 0.2s ease;
}

.form-check:hover {
  background: #e8eef9;
}

.form-check-input:checked + .form-check-label {
  color: #0e2f7b;
  font-weight: 500;
}

/* Empty state styling */
.empty-state {
  text-align: center;
  padding: 3rem;
  background: white;
  border-radius: 12px;
  margin: 2rem 0;
}

.empty-state img {
  width: 120px;
  margin-bottom: 1.5rem;
  opacity: 0.7;
}

.empty-state h6 {
  color: #0e2f7b;
  margin-bottom: 0.5rem;
}

.empty-state p {
  color: #6c757d;
  margin-bottom: 0;
}

  </style>
</head>
<body class="bg-light">

  <div id="overlay" class="overlay"></div>

  <!-- HEADER -->
  <header 
    class="text-white p-3 mb-2 d-flex align-items-center justify-content-between" 
    style="background-color: #0e2f7b;"
  >
    <h4 class="mb-0">Montclair Pickleball Player Portal</h4>
    <img 
      src="icons/banner-logo.png" 
      alt="Logo" 
      style="height: 40px;"
    >
  </header>

  <!-- EMAIL VERIFICATION SECTION (Only for first-time devices) -->
  <section id="verification-section" class="shadow-sm">
    <h5>Welcome to Montclair Pickleball</h5>
    <p>Please enter your email to get started.</p>
    <form id="verification-form">
      <div class="mb-3">
        <label for="verify-email-input" class="form-label">Email Address</label>
        <input type="text" class="form-control" id="verify-email-input" required />
      </div>
      <button id="verificationBtn" type="submit" class="btn btn-primary w-100 mb-2">
        Continue
      </button>
    </form>

    <!-- Email verification code entry -->
    <div id="code-entry" style="display: none;">
      <div id="code-entry-loading" class="text-center mb-3">
        <div class="spinner-border text-primary" role="status"></div>
        <p class="mt-2">Sending verification code...</p>
      </div>
      <div id="code-entry-form" style="display: none;">
        <p>Enter the 6-digit code we sent to your email:</p>
        <div class="mb-3">
          <input type="text" class="form-control" id="verify-code-input" placeholder="123456" />
        </div>
        <div id="wrongCodeAlert" class="alert alert-danger" style="display:none" role="alert">
          Invalid code. Please re-check your email or try again.
        </div>
        <button id="verify-code-button" class="btn btn-success w-100 mb-2">
          Verify Code
        </button>
        <button id="verificationRefresh" class="btn btn-secondary w-100">Try Again</button>
      </div>
    </div>

    <!-- Login options for existing users -->
    <div id="login-options" style="display: none;">
      <p class="text-muted small mb-3">Please choose how you would like to sign in</p>
      <div class="d-grid gap-2">
        <button id="btn-email-verify" class="btn btn-primary">
          Login with Email Verification
        </button>
        <button id="btn-password-login" class="btn btn-outline-primary">
          Login with Password
        </button>
      </div>
      <div id="new-password-dialogue" class="mini-dialogue subtle-dialogue mt-4 mx-auto">
        <div class="mini-dialogue-arrow"></div>
        <span><strong>*NEW*</strong> Create a password so you don't have to verify your email to login!</span>
      </div>
    </div>

    <!-- Password login form -->
    <form id="password-login-form" style="display: none;">
      <h5 class="mb-3">Login with Password</h5>
      <div class="mb-3">
        <label for="login-email" class="form-label">Email</label>
        <input type="email" class="form-control" id="login-email" required />
      </div>
      <div class="mb-3">
        <label for="login-password" class="form-label">Password</label>
        <input type="password" class="form-control" id="login-password" required />
      </div>
      <div class="alert alert-danger" id="login-error" style="display: none;"></div>
      <div class="alert alert-success" id="password-reset-success" style="display: none;">
        Password reset email sent! Please check your inbox.
      </div>
      <div class="d-grid gap-2">
        <button type="submit" class="btn btn-primary">Login</button>
        <button type="button" class="btn btn-link" id="btn-forgot-password">Forgot Password?</button>
        <button type="button" class="btn btn-link" id="btn-create-password">Don't have a password yet? Click here to add one</button>
        <button type="button" class="btn btn-secondary" id="btn-back-to-options">Back</button>
      </div>
    </form>

    <!-- Create password account form -->
    <form id="create-password-form" style="display: none;">
      <h5 class="mb-3">Create Password</h5>
      <div class="mb-3">
        <label for="create-email" class="form-label">Email</label>
        <input type="email" class="form-control" id="create-email" required readonly />
      </div>
      <div class="mb-3">
        <label for="create-password" class="form-label">Password</label>
        <input type="password" class="form-control" id="create-password" required />
      </div>
      <div class="mb-3">
        <label for="confirm-password" class="form-label">Confirm Password</label>
        <input type="password" class="form-control" id="confirm-password" required />
      </div>
      <div class="alert alert-danger" id="create-error" style="display: none;"></div>
      <div class="d-grid gap-2">
        <button type="submit" class="btn btn-primary">Create Password</button>
        <button type="button" class="btn btn-secondary" id="btn-back-from-create">Back to Login</button>
      </div>
    </form>

    <!-- New user registration prompt -->
    <div id="new-user-prompt" style="display: none;">
      <h5 class="mb-3">New to Montclair Pickleball?</h5>
      <p>We'll help you get started with a new account.</p>
      <div class="d-grid gap-2">
        <a href="registration.html" class="btn btn-primary">Create New Account</a>
        <button type="button" class="btn btn-secondary" id="btn-back-to-email">Try Different Email</button>
      </div>
    </div>
  </section>

  <!-- MAIN TAB CONTENT (Once verified) -->
  <section id="tab-content-section">
    <div class="tab-content" id="myTabContent">

            <!-- HOME TAB (new) -->
    <div class="tab-pane fade show active" id="tab-home" role="tabpanel">
        <div class="bg-white p-3 rounded shadow-sm">
            <div id="login-spinner">
                <div class="text-center">
                  <div class="spinner-border text-primary mb-2" role="status"></div>
                  <p id = "loginText" class="mb-0">Logging you in!</br>This may take up to 20 seconds...<br>Please don't refresh this page.</nr></p>
                </div>
              </div>
        <div id="home-content">
          <h5>Home</h5>
          <p id="welcomeMsg">Welcome to our Montclair Pickelball Player Portal!</p>
          <div class="list-group">
            <a href="#tab-profile" 
               id="home-link-profile" 
               class="list-group-item list-group-item-action">
              View Profile
            </a>
            <a href="#tab-register" 
               id="home-link-register" 
               class="list-group-item list-group-item-action">
              Register for a Program
            </a>
            <a href="#tab-registrations" 
               id="home-link-registrations" 
               class="list-group-item list-group-item-action">
              My Registrations
            </a>
            <a href="subscription.html" 
            id="home-link-memberships" 
            class="list-group-item list-group-item-action">
            Purchase or Manage Membership
          </a>
            <a href="forum.html" 
                id="home-link-forum" 
                class="list-group-item list-group-item-action"
                style = "display: none">
                Community Chat (Members Only)
            </a>
          <a href="https://www.montclairpickleballbc.com" target="_blank" rel="noopener noreferrer" class="list-group-item list-group-item-action">
              Fair Lawn Website
          </a>
          <a href="https://www.montclairpickleball.com" target="_blank" rel="noopener noreferrer" class="list-group-item list-group-item-action">
            Montclair Website</a>
          <a class="list-group-item list-group-item-action" data-bs-toggle="collapse" href="#moreOptions" role="button" aria-expanded="false" aria-controls="moreOptions">
            Contact Us <span class="arrow">&#9660;</span>
          </a>
          <div class="collapse" id="moreOptions">
            <div class="list-group">
              <a href="mailto:contact@montclairpickleball.com" class="list-group-item list-group-item-action bg-white border rounded mb-1 mt-1 shadow-sm py-2">
                Email: contact@montclairpickleball.com
              </a>
              <a href="tel:2013082473" class="list-group-item list-group-item-action bg-white border rounded mb-1 shadow-sm py-2">
                Phone: 201-308-2473
              </a>
              <a href="https://www.instagram.com/montclairpickleball/?hl=en" target="_blank" rel="noopener noreferrer" class="list-group-item list-group-item-action bg-white border rounded mb-1 shadow-sm py-2">
                Instagram
              </a>
              <a href="https://www.facebook.com/montclairpickleball/" target="_blank" rel="noopener noreferrer" class="list-group-item list-group-item-action bg-white border rounded mb-1 shadow-sm py-2">
               Facebook
              </a>
            </div>            
          </div>
          </div>
        </div>
        </div>
      </div>

      <!-- PROFILE TAB -->
      <div class="tab-pane fade" id="tab-profile" role="tabpanel">
        <div class="bg-white p-3 rounded shadow-sm" id="profile-container">

          <!-- Actual Profile Content -->
          <div id="profile-content">
            <h5>Profile</h5>
            <p><strong>First Name:</strong> <span id="profile-first-name"></span></p>
            <p><strong>Last Name:</strong> <span id="profile-last-name"></span></p>
            <p><strong>Phone:</strong> <span id="profile-phone"></span></p>
            <p><strong>Email:</strong> <span id="profile-email"></span></p>
            <p><strong>Card on File:</strong>
                <span id="profile-card-last4">No card on file</span>
                <!-- We'll show/hide or change the text on this button in JS -->
                <button id="profile-card-button" 
                        class="btn btn-sm btn-outline-secondary ms-2" 
                        style="display: none;">
                </button>
            </p>              
            <!-- Display user credit from PromoCodes -->
            <p><strong>Credit:</strong> <span id="profile-credit-amount">No credit available</span></p>
            
            <div id="profileBenefits"></div>

            <button id="logout-button" class="btn btn-danger w-100 mt-3">Logout</button>
          </div>
        </div>
      </div>

      <!-- REGISTER TAB -->
      <div class="tab-pane fade" id="tab-register" role="tabpanel">

                <!-- Add new spinner -->
          <div id="register-tab-spinner" class="loading-container">
            <div class="loading-content">
              <div class="pickleball-icon">
                <img src="icons/banner-logo.png" alt="Logo">
              </div>
              
              <div class="loading-dots">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
              </div>
              <p class="loading-subtitle">Loading available sessions...</p>
            </div>
          </div>
          
          <!-- Add error message container -->
          <div id="register-tab-error" class="alert alert-warning">
            <div class="pickleball-icon">
              <img src="icons/banner-logo.png" alt="Logo">
            </div>
            <h4>Unable to Load Sessions</h4>
            <p class="mb-3">We encountered an error while loading the available sessions. Please try again.</p>
            <button class="btn btn-primary" onclick="retryLoadSessions()">Retry Loading</button>
          </div>
        <div class="bg-white p-3 rounded shadow-sm position-relative" id="register-container">

          <!-- Session Loading Spinner -->
          <div id="session-spinner">
            <div class="text-center">
              <div class="spinner-border text-primary mb-2" role="status"></div>
              <p class="mb-0">Loading Session...</p>
            </div>
          </div>

          <!-- Payment Spinner overlay while processing payment -->
          <div id="payment-spinner">
            <div class="text-center">
              <div class="spinner-border text-primary mb-2" role="status"></div>
              <p class="mb-0">Processing Registration...</p>
            </div>
          </div>

          <!-- Payment success alert (may show credit left) -->
          <div id="payment-success" class="alert alert-success" role="alert">
            Success! Your registration has been submitted.
          </div>

          <h5>Select a Location/Session</h5>

          <!-- [CHANGED] 1) Session Cards Container -->
          <div id="session-cards" class="row row-cols-1 row-cols-sm-2 row-cols-md-4 g-1">
            <!-- Dynamically populated in loadSessions() -->
          </div>

          <h6 id="membership-message" class="text-center mb-0" style="display:none;"></h6>
          <a id="extndMsg" href="subscription.html" class="text-center mb-4" style="display:none;">You can expand your membership dates here.</a>

          <!-- [CHANGED] 2) Filter Section (Progressive) -->
          <div id="filter-section">
            <!-- We still use the same 3 filters, but they appear one at a time. -->

            <!-- [ADDED] Toggle Calendar/List Button & List-View Container (initially hidden) -->
            <div id="toggle-view-container" style="display: none;">
                <button id="btn-toggle-calendar-view" class="btn btn-outline-primary btn-sm mb-2 mt-7 mx-auto d-block">
                  Switch to Calendar View (Level Based)
                </button>
            </div>
  
<!-- [ADJUSTED] List View Container -->
<div id="list-view-container" style="display: none;">
    <div id="standardized-level-filter-group" style="display: none;">
        <label class="form-label"><strong>Filter By Your Level</strong></label>
        <select id="standardized-level-filter" class="form-select mb-3">
          <option value="">--Select Your Level--</option>
        </select>
    </div>

    <div class="d-flex justify-content-between align-items-center mb-2">
        <button id="btn-list-prev" class="btn btn-sm btn-secondary">&laquo; Previous 7 Days</button>
        <button id="btn-list-next" class="btn btn-sm btn-secondary">Next 7 Days &raquo;</button>
    </div>
  
    <!-- The new FullCalendar container -->
    <div style="overflow-x: auto; max-width: 100%;">
    <div id="register-calendar"></div>
    </div>
    
  </div>
  
  
            
            <!-- Category Filter -->
            <div id="category-filter-group" style="display: none;">
              <label class="form-label"><strong>Select Program</strong></label>
              <select id="category-filter" class="form-select mb-3">
                <option value="">--Select a Category--</option>
              </select>
            </div>

            <!-- Level Filter -->
            <div id="level-filter-group" style="display: none;">
              <label class="form-label"><strong>Select Level</strong></label>
              <select id="level-filter" class="form-select mb-3">
                <option value="">--Select a Level--</option>
              </select>
            </div>

            <!-- Day/Time Filter -->
            <div id="daytime-filter-group" style="display: none;">
              <label class="form-label"><strong>Select Day/Time</strong></label>
              <select id="daytime-filter" class="form-select mb-3">
                <option value="">--Select a Day/Time--</option>
              </select>
            </div>
          </div>

          <!-- [CHANGED] 3) Program Cards Container -->
          <div id="program-cards-container"></div>

          <!-- The old cart-section is still in code, but hidden. We'll keep the logic for payment. -->
          <hr/>
          <div id="cart-section" style="display: none;">
            <h6>Your Cart</h6>
            <table class="table table-striped table-sm" id="cart-table">
              <thead>
                <tr>
                  <th>Program</th>
                  <th>Session</th>
                  <th></th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>

            <div id="partnerName" class="form-group col-md-6" style="display:none">
              <label for="partner-name">Name of Partner (For Showdown)</label>
              <input type="text" id="partner-name" name="partner-name" class="form-control"/>
            </div>
          
            <div id="amount-due-line"></div>
            <div id="breakdown-line"></div>
          
            <!-- TWO buttons -->
            <div class="d-flex gap-2 mt-3">
              <!-- 1) Charge On-File -->
              <button id="btn-charge-on-file" class="btn btn-primary flex-fill">
                Charge Card on File
              </button>
          
              <!-- 2) One-Time Payment -->
              <button id="btn-credit-debit" class="btn btn-secondary flex-fill">
                Credit/Debit Card
              </button>
            </div>
          </div>          

        </div>
      </div>

      <!-- MY REGISTRATIONS TAB -->
      <div class="tab-pane fade" id="tab-registrations" role="tabpanel">
        <div class="bg-white p-3 rounded shadow-sm position-relative" id="registrations-container">
          <h5>My Registrations</h5>

          <div id="registrations-spinner">
            <div class="spinner-border text-primary mb-2" role="status"></div>
            <p class="mb-0">Loading Registrations...<br>New registrations may take a couple minutes to appear.</p>
          </div>
          <div id="registrations-content">
            <div id="calendar"></div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- FIXED BOTTOM NAV -->
  <nav id="mainNav" class="nav nav-bottom d-flex justify-content-around d-none">
    <a class="nav-link active" data-bs-toggle="tab" data-bs-target="#tab-home" role="tab">
        <span class="d-block">Home</span>
      </a>
    <a class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-register" role="tab">
      <span class="d-block">Register</span>
      <span class="loading-indicator"></span>
    </a>
    <a class="nav-link" data-bs-toggle="tab" data-bs-target="#tab-registrations" role="tab">
      <span class="d-block">My Programs</span>
    </a><!-- Mobile version (icon only) -->
    <a class="nav-link nav-profile d-md-none" data-bs-toggle="tab" data-bs-target="#tab-profile" role="tab" aria-label="Profile">
      <i class="bi bi-person-circle"></i>
    </a>
    
    <!-- Desktop version (text only) -->
    <a class="nav-link d-none d-md-block" data-bs-toggle="tab" data-bs-target="#tab-profile" role="tab" aria-label="Profile">
      My Profile
    </a>

  </nav>

  <!-- PAYMENT MODAL -->
  <div class="modal fade" id="paymentModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Add Payment Profile</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p id="cardOnFileModalText">Add a card on file to make registration easier! This is not required, but it is recommended.</p>
          <form id="payment-form">
            <div class="mb-3">
              <label for="name-input" class="form-label">Name</label>
              <input type="text" class="form-control" id="name-input" required />
            </div>
            <div class="mb-3">
              <label for="card-element" class="form-label">Card</label>
              <div id="card-element" class="form-control"></div>
              <div id="card-errors" class="card-errors"></div>
            </div>
            <button id="submitCardOnFile" type="submit" class="btn btn-primary w-100">Add Payment Profile</button>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- ONE-TIME PAYMENT MODAL -->
  <div class="modal fade" id="oneTimePaymentModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Pay with Credit/Debit Card</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>Please enter your card details to complete the payment. This card will <strong>not</strong> be saved on file.</p>
          <form id="one-time-payment-form">
            <div class="mb-3">
              <label for="otpf-name" class="form-label">Name on Card</label>
              <input type="text" class="form-control" id="otpf-name" required />
            </div>
            <div class="mb-3">
              <label for="otpf-card-element" class="form-label">Card</label>
              <div id="otpf-card-element" class="form-control"></div>
              <div id="otpf-card-errors" class="card-errors text-danger mt-1"></div>
            </div>
            <!-- [NEW] Save Card Checkbox Container -->
            <div id="save-card-checkbox-container" class="form-check mb-3" style="display: none;">
                <input type="checkbox" class="form-check-input" id="save-card-checkbox" />
                <label class="form-check-label" for="save-card-checkbox">
                Save this card on file for future use
                </label>
            </div>
            <button id="oneTimeSubmitBtn" type="submit" class="btn btn-primary w-100">Pay Now</button>
          </form>
        </div>
      </div>
    </div>
  </div>

  <!-- Credit Alert Modal-->

  <div class="modal fade" id="creditAlertModal" tabindex="-1" aria-labelledby="creditAlertModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="creditAlertModalLabel">Member Benefit Notice</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>
            You will be charged at full price for the days within this package that fall outside of your current membership cycle. 
            If you would like to extend your membership to reserve the full package using membership credits, 
            click <a href="subscription.html" class="text-decoration-none">here</a>.
          </p>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          <a href="subscription.html" class="btn btn-primary">Extend Membership</a>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="welcomeModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false" aria-labelledby="welcomeModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="welcomeModalLabel">Welcome!</h5>
        </div>
        <div class="modal-body">
          Hey There! It looks like you haven't played with us before. We can't wait to meet you on the court! We just need a bit more information from you to finish creating your account. Please click "Get Started" below to get set up.
        </div>
        <div class="modal-footer justify-content-center">
          <a href="registration.html" class="btn btn-primary">Get Started</a>
          <button type="button" class="btn btn-secondary" onclick="localStorage.removeItem('playerEmail'); location.reload();">
            Try Another Email
          </button>
        </div>
      </div>
    </div>
  </div>  

  <div class="modal fade" id="cartAlertModal" tabindex="-1" aria-labelledby="cartAlertModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="cartAlertModalLabel">Sold Out Program Notice</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>
            A program has been removed from your cart because it became Sold Out before you completed your purchase.
          </p>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- [CHANGED] Floating Cart Summary Pill -->
  <div id="cart-summary-pill" style="display: none;">0 items - $0.00</div>

  <!-- Bootstrap 5 JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<!-- PART 1/3 START -->
<script>

function forceRefreshIfFromSubscription() {
    // Check if the referrer URL ends with or contains 'subscription.html'
    if (document.referrer && document.referrer.includes('subscription.html')) {
      setTimeout(() => {
        window.location.reload();
      }, 5000);
    }
  }

  // Example usage: run on DOMContentLoaded
  document.addEventListener('DOMContentLoaded', forceRefreshIfFromSubscription);

  /************************************************************
   * 1) CONFIG & STRIPE SETUP
   ************************************************************/
  const GAS_PROXY         = 'https://merry-rugelach-c028d1.netlify.app/.netlify/functions/proxy';
  const FIND_STRIPE_URL   = 'https://merry-rugelach-c028d1.netlify.app/.netlify/functions/findStripe';
  const CREATE_STRIPE_URL = 'https://merry-rugelach-c028d1.netlify.app/.netlify/functions/createStripe';
  const CHARGE_CART_URL   = 'https://merry-rugelach-c028d1.netlify.app/.netlify/functions/chargeCart';
  const GET_CREDIT_URL    = 'https://merry-rugelach-c028d1.netlify.app/.netlify/functions/proxy?action=getCredit';

  const stripe = Stripe('pk_live_51N9BzSHaWNal9rme3vwhLRs3vRgdqPQO35KZ2WQHPvefzbh2dP1VRCLTc8wKBNxN3jk8VXkeu8P3MJxnoJ1A3JaP00OotZGNnb');
  const elements = stripe.elements();
  const cardElement = elements.create('card');
  cardElement.mount('#card-element');

  // Create a second Elements instance
  const oneTimeElements = stripe.elements();
  const oneTimeCard = oneTimeElements.create('card');
  oneTimeCard.mount('#otpf-card-element'); // "otpf" = One-Time Payment Form

  const ADMIN_PASSWORD = 'password';

  let currentPlayer = null; 
  let allSessions = [];   // holds full data for all sessions
  let cartItems = [];
  let freeSlotUsageMap = {};

  // We'll keep track of the currently selected session, category, level, dayTime
  let selectedSession = null;
  let selectedCategory = null;
  let selectedLevel = null;
  let selectedDayTime = null;
  let selectedStandardizedLevel = null;


  // We'll keep a global array of "allProducts" for the chosen session
  let allProducts = [];

  // Globals for the "Toggle Calendar View" / 7-day listing
  let isListView = false;          // Tracks if we are currently in "list view"
  let listViewStartDate = null;    // Start date for the current 7-day range
  let minProgramDate = null;       // Earliest date in the selected session's programs
  let maxProgramDate = null;       // Latest date in the selected session's programs
  let registerCalendar = null;

   // Add at the top with other state variables
  let showOnlyPackages = false;

  let currentActiveTab = '#tab-home'; // or whatever your default is

  document.querySelectorAll('a[data-bs-toggle="tab"]').forEach(tabLink => {
    tabLink.addEventListener('shown.bs.tab', function (e) {
      // e.target is the newly activated tab link
      currentActiveTab = e.target.getAttribute('data-bs-target');
      if (currentActiveTab != '#tab-register') {
        document.getElementById('cart-summary-pill').style.display = 'none';
      } else {
        updateCartSummaryPill();
      }
    });
  });

  const CATEGORY_COLORS = {
  "Adult Clinics": "#FF851B",         // example: bright orange
  "Open Play": "#F1C40F",             // example: yellow
  "Guided Open Play": "#9B59B6",      // darker green
  "Coach Guided Drilling": "#0074D9", // example: blue
  "Guided Drilling": "#0074D9",
  };

  const CATEGORY_DARK_COLORS = {
  "Adult Clinics": "#2ECC40",         // ~ darkened version of #FF851B
  "Open Play": "#2ECC40",             // ~ darkened #2ECC40
  "Guided Open Play": "#2ECC40",      // ~ darkened #3D9970
  "Coach Guided Drilling": "#2ECC40", // ~ darkened #0074D9
  "Guided Drilling": "#2ECC40",
  };


  document.getElementById('cart-summary-pill').addEventListener('click', () => {
  window.scrollTo({
      top: document.body.scrollHeight,
      behavior: 'smooth'
  });
  });

  //HOME SCREEN LINKS TO TABS

  document.querySelector('#home-content a[href="#tab-profile"]').addEventListener('click', function (e) {
e.preventDefault();
// Programmatically show the Profile tab
const profileTrigger = document.querySelector('[data-bs-target="#tab-profile"]');
if (profileTrigger) {
  const tabObj = new bootstrap.Tab(profileTrigger);
  tabObj.show();
}
});

document.querySelector('#home-content a[href="#tab-register"]').addEventListener('click', function (e) {
e.preventDefault();
// Programmatically show the Profile tab
const profileTrigger = document.querySelector('[data-bs-target="#tab-register"]');
if (profileTrigger) {
  const tabObj = new bootstrap.Tab(profileTrigger);
  tabObj.show();
}
});

document.querySelector('#home-content a[href="#tab-registrations"]').addEventListener('click', function (e) {
e.preventDefault();
// Programmatically show the Profile tab
const profileTrigger = document.querySelector('[data-bs-target="#tab-registrations"]');
if (profileTrigger) {
  const tabObj = new bootstrap.Tab(profileTrigger);
  tabObj.show();
}
});
  /************************************************************
   * 1b) FIREBASE AND MEMBERSHIP CONFIGURATION
   ************************************************************/

   const firebaseConfig = {
    apiKey: "AIzaSyDP2YjuFB8SiSJTsMH7yqGdyrMpiK05AEo",
    authDomain: "mp-subscriptions.firebaseapp.com",
    databaseURL: "https://mp-subscriptions-default-rtdb.firebaseio.com",
    projectId: "mp-subscriptions",
    storageBucket: "mp-subscriptions.firebasestorage.app",
    messagingSenderId: "228607825379",
    appId: "1:228607825379:web:02cddb56b0465cca603cd6",
    measurementId: "G-8NXV5DBFZB"
  };

  // Initialize Firebase
  const app = firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.database();

  // We'll use this discount map (Option B: each category has membership-tier-specific discount factors)
  const discountMap = {
  "Play With Pro": {
    Gold: 0.2,
    Silver: 0.2,
    TripleCrown: 1
  },
  "Guided Open Play": {
    freeEligible: true,
    Gold: 0.2,
    Silver: 0.2,
    TripleCrown: 1
  },
  "Adult Clinics": {
    freeEligible: true,
    Gold: 0.2,
    Silver: 0.2,
    TripleCrown: 1
  },
  "Guided Drilling": {
    freeEligible: true,
    Gold: 0.2,
    Silver: 0.2,
    TripleCrown: 1
  },
  "Advanced Adult Camps": {
    Gold: 0.2,
    Silver: 0.2,
    TripleCrown: 1.0
  },
  "Open Play": {
    Gold: 1.0,
    Silver: 1.0,
    TripleCrown: 1.0
  },
    "Pickleball & Pizza": {
    Gold: 0.2,
    Silver: 0.2,
    TripleCrown: 1.0
  },
    "Doubles for Singles": {
    Gold: 0.2,
    Silver: 0.2,
    TripleCrown: 1.0
  },
    "Saturday Showdown": {
    Gold: 0.2,
    Silver: 0.2,
    TripleCrown: 1.0
  },
    "Doubles for Couples": {
    Gold: 0.2,
    Silver: 0.2,
    TripleCrown: 1.0
  }
};

// Step 1: Function to check cart items against the updated product data.
function checkCartForSoldOut() {
  if (!selectedSession) return; // Nothing to check if no session is selected.

  const currentProducts = selectedSession.products || [];
  let removedAny = false;

  // Filter out any cart items that are now sold out.
  cartItems = cartItems.filter(item => {
    const product = currentProducts.find(prod => prod.program === item.program);
    // If we find the product and it's sold out, remove this item.
    if (product && product.soldOut) {
      removedAny = true;
      return false; // remove this item from the cart
    }
    return true; // keep this item
  });

  // Optionally notify the user.
  if (removedAny) {
    const cartAlertModalEl = new bootstrap.Modal(document.getElementById('cartAlertModal'));
    cartAlertModalEl.show();
  }
  
  updateCartTable(); // Update cart display accordingly.
}

// Step 2: Update your refresh function to call the sold-out check.
function refreshData() {
  loadSessions()
    .then(() => {
      // If a session was already selected, update it from the refreshed sessions.
      if (selectedSession) {
        const updatedSession = allSessions.find(s => s.spreadsheetId === selectedSession.spreadsheetId);
        if (updatedSession) {
          selectedSession = updatedSession;
          allProducts = updatedSession.products || [];
        }
      }
      
      // Now check the cart to remove any sold-out items.
      checkCartForSoldOut();

      // Reapply current filters and update the UI.
      if (isListView) {
        renderProgramListForRange();
      } else {
        // Use the new filtered rendering that maintains grouping and filters
        renderFilteredPrograms();
      }
    })
    .catch(err => console.error("Error refreshing sessions:", err));
}

// Finally, continue to refresh every 60 seconds.
setInterval(refreshData, 120000);



  /************************************************************
   * 2) ON PAGE LOAD
   ************************************************************/
  window.addEventListener('DOMContentLoaded', () => {
    // Set up Firebase Auth state listener
    auth.onAuthStateChanged(async (user) => {
      if (user) {
        // User is signed in
        document.getElementById('tab-content-section').style.display = 'block';
        document.getElementById('verification-section').style.display = 'none';
        initiateValidationFlow(user.email);
      } else {
        // No user is signed in
        document.getElementById('verification-section').style.display = 'block';
        document.getElementById('tab-content-section').style.display = 'none';
      }
    });
  });

  /************************************************************
   * 3) SPINNER LOGIC
   ************************************************************/
   let activeSpinners = 0; // Track active spinners

    function toggleScrollAndClicks(enable) {
      if (enable) {
        activeSpinners++;
        document.body.classList.add('modal-open');
        document.getElementById('overlay').style.display = 'block';
      } else {
        activeSpinners = Math.max(0, activeSpinners - 1);
        if (activeSpinners === 0) {
          document.body.classList.remove('modal-open');
          document.getElementById('overlay').style.display = 'none';
        }
      }
    }

    function showProfileSpinner(shouldShow) {
      const spinner = document.getElementById('login-spinner');
      const homeContent = document.getElementById('home-content');
      const profileContent = document.getElementById('profile-content');
      if (!spinner || !profileContent) return;

      toggleScrollAndClicks(shouldShow);
      spinner.style.display = shouldShow ? 'block' : 'none';
      profileContent.style.display = shouldShow ? 'none' : 'block';
      homeContent.style.display = shouldShow ? 'none' : 'block';
    }

    function showPaymentSpinner(shouldShow) {
      const spinner = document.getElementById('payment-spinner');
      const successBox = document.getElementById('payment-success');
      if (!spinner || !successBox) return;

      toggleScrollAndClicks(shouldShow);
      spinner.style.display = shouldShow ? 'block' : 'none';
      if (shouldShow) successBox.style.display = 'none';
    }

  function showSessionSpinner(shouldShow) {
    const spinner = document.getElementById('session-spinner');
    if (!spinner) return;
    spinner.style.display = shouldShow ? 'block' : 'none';
  }

  function showRegistrationsSpinner(shouldShow) {
    const spinner = document.getElementById('registrations-spinner');
    const content = document.getElementById('registrations-content');
    if (!spinner || !content) return;
    spinner.style.display = shouldShow ? 'block' : 'none';
    content.style.display = shouldShow ? 'none' : 'block';
  }

  function showPaymentSuccess(shouldShow) {
    const successBox = document.getElementById('payment-success');
    if (!successBox) return;
    successBox.style.display = shouldShow ? 'block' : 'none';
  }

  /************************************************************
   * 4) EMAIL VERIFICATION
   ************************************************************/
  // Handle verification form submission
  document.getElementById('verification-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const emailInput = document.getElementById('verify-email-input').value.trim().toLowerCase();
    if (!emailInput) return;
    
    document.getElementById('verificationBtn').textContent = 'Processing...';
    document.getElementById('verificationBtn').disabled = true;

    try {
      // Check if user exists in Firebase
      const playerData = await getPlayerInfoFromFirebase(emailInput);
      
      if (playerData.success && playerData.player) {
        // Existing user - update welcome message and show login options
        const welcomeHeading = document.querySelector('#verification-section h5');
        const welcomeParagraph = document.querySelector('#verification-section > p');
        if (welcomeHeading && welcomeParagraph) {
          welcomeHeading.textContent = `Welcome Back, ${playerData.player.firstName}!`;
          welcomeParagraph.style.display = 'none';
        }
        
        document.getElementById('verification-form').style.display = 'none';
        document.getElementById('login-options').style.display = 'block';
        
        // Pre-fill email in login forms
        document.getElementById('login-email').value = emailInput;
        document.getElementById('create-email').value = emailInput;
      } else {
        // New user - show registration prompt
        document.getElementById('verification-form').style.display = 'none';
        // Hide the welcome message and email prompt
        document.querySelector('#verification-section h5').style.display = 'none';
        document.querySelector('#verification-section > p').style.display = 'none';
        document.getElementById('new-user-prompt').style.display = 'block';
      }
    } catch (err) {
      alert('Error checking user: ' + err.message);
    } finally {
      document.getElementById('verificationBtn').textContent = 'Continue';
      document.getElementById('verificationBtn').disabled = false;
    }
  });

  document.getElementById('verificationRefresh').addEventListener('click', function() {
  // Standard page refresh
  window.location.reload();
  
});

  // Update the verify-code-button click handler
  document.getElementById('verify-code-button').addEventListener('click', async () => {
    const userCode = document.getElementById('verify-code-input').value.trim();
    const actualCode = window.__verificationCode;
    const email = document.getElementById('verify-email-input').value.trim().toLowerCase();
    
    if (userCode === actualCode) {
      // Hide verification section and show main content
      document.getElementById('verification-section').style.display = 'none';
      document.getElementById('tab-content-section').style.display = 'block';
      
      // Proceed with validation flow
      initiateValidationFlow(email);
    } else {
      document.getElementById('wrongCodeAlert').style.display = 'block';
    }
  });

  /************************************************************
   * 5) INITIATE VALIDATION FLOW (Players + Stripe + Credit)
   ************************************************************/
   async function initiateValidationFlow(email) {
    if (!email) {
      console.error('No email provided to initiateValidationFlow');
      return;
    }

    document.getElementById('mainNav').classList.remove('d-none');
    showMessage(`initiateValidationFlow for email: ${email}`, 'debug');
    showProfileSpinner(true);

    try {
      // Get player info from Firebase
      const playerData = await getPlayerInfoFromFirebase(email);
      showMessage(`playerData: ${JSON.stringify(playerData)}`, 'debug');

      if (!playerData.success || !playerData.player) {
        const welcomeModal = new bootstrap.Modal(document.getElementById('welcomeModal'));
        welcomeModal.show();
        showMessage(`Error retrieving or invalid player: ${playerData.error}`, 'error');
        showProfileSpinner(false);
        return;
      }
      currentPlayer = playerData.player;

      // 2) Check Stripe
      const stripeUrl = `${FIND_STRIPE_URL}?email=${encodeURIComponent(email)}`;
      const stripeResp = await fetch(stripeUrl);
      const stripeData = await stripeResp.json();
      showMessage(`stripeData: ${JSON.stringify(stripeData)}`, 'debug');

      if (!stripeData.success) {
        showMessage('Error checking Stripe: ' + (stripeData.error || ''), 'error');
        showProfileSpinner(false);
        //return;
      }
      if (stripeData.exists) {
        currentPlayer.cardLast4 = stripeData.cardLast4 || null;
      } else {
        showMessage('No Stripe customer found => Payment Profile needed', 'debug');
      }

      // Remove credit fetch since it's now included in player data
      showMessage(`Credit from Firebase: ${currentPlayer.credit}`, 'debug');

      // 4) Fetch membership from Firebase Realtime Database
      try {
        const dbRef = firebase.database().ref('subscriptions');
        // We'll read ALL subscriptions and find the one that matches currentPlayer.email
        const snapshot = await dbRef.once('value');
        const subsData = snapshot.val() || {};
        let membershipType = null;
        let membershipEnd = null;

        // We search for a record with .email === currentPlayer.email
        Object.keys(subsData).forEach(key => {
          const sub = subsData[key];
          if (sub && sub.email && sub.email.toLowerCase() === currentPlayer.email.toLowerCase()) {
            // Found a match
            if (sub.active) {
              membershipType = sub.membershipType || null;
              membershipEnd  = sub.endDate || null;
              membershipStart = sub.startDate || null;
            }
          }
        });

        
        currentPlayer.membershipType    = membershipType;
        currentPlayer.membershipEndDate = membershipEnd;
        currentPlayer.membershipStartDate = membershipStart;

        //Only members can use forum. This is anyone with an unexpired membership
        if (currentPlayer.membershipType) {
          const now = new Date();
          const endDate = new Date(membershipEnd);
          
          // Only show the forum link if membershipEnd is in the future
          if (endDate > now) {
            document.getElementById('home-link-forum').style.display = 'block';
          }
        }

        showMessage(`Membership found: type=${membershipType}, end=${membershipEnd}`, 'debug');
      } catch (firebaseErr) {
        showMessage('Error fetching membership from Firebase: ' + firebaseErr.message, 'error');
        currentPlayer.membershipType = null;
        currentPlayer.membershipEndDate = null;
        currentPlayer.membershipStartDate = null;
      }

      await fetchExistingFreeSlots(currentPlayer.email);

      // Show profile
      setProfileData(currentPlayer);

      updateMembershipMessage();

      // If no stripe => show modal

      // Load sessions
      showSessionSpinner(true);
      await loadSessions();
      showSessionSpinner(false);
      showProfileSpinner(false);
      uploadUserEmail();

      if (!stripeData.exists && !document.referrer && !document.referrer.includes('subscription.html')) {
        const modalEl = new bootstrap.Modal(document.getElementById('paymentModal'));
        modalEl.show();
      }
      if (currentPlayer.firstName) {
      document.getElementById('welcomeMsg').textContent = `Hey ${currentPlayer.firstName}! Welcome to our Montclair Pickelball Player Portal.`;
    }
      
    } catch (err) {
      showMessage('initiateValidationFlow error: ' + err.message, 'error');
      showProfileSpinner(false);
      showSessionSpinner(false);
    }
  }

  async function uploadUserEmail() {
  const user = auth.currentUser;
  if (!user || !user.email) {
    console.log("No authenticated user found.");
    return;
  }
  
  try {
    await firebase.database().ref('users').push({ email: user.email });
    console.log("Email uploaded successfully!");
  } catch (error) {
    console.error("Error uploading email:", error);
  }
}


  /************************************************************
   * 6) PAYMENT PROFILE FORM
   ************************************************************/
  document.getElementById('payment-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    const nameInput = document.getElementById('name-input').value.trim();
    const email = currentPlayer?.email || '';
    document.getElementById('submitCardOnFile').textContent="Processing...";
    document.getElementById('submitCardOnFile').disabled=true;

    showMessage(`Creating PaymentMethod for email: ${email}`, 'debug');
    const { paymentMethod, error } = await stripe.createPaymentMethod({
      type: 'card',
      card: cardElement,
      billing_details: { name: nameInput, email }
    });
    if (error) {
      showMessage('Stripe error: ' + error.message, 'error');
      return;
    }
    showMessage(`PaymentMethod created: ${paymentMethod.id}`, 'debug');

    const payload = { name: nameInput, email, paymentMethodId: paymentMethod.id };
    try {
      const resp = await fetch(CREATE_STRIPE_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data = await resp.json();
      showMessage(`createStripe response: ${JSON.stringify(data)}`, 'debug');

      if (!data.success) {
        showMessage('Error creating Stripe customer: ' + (data.error || ''), 'error');
        return;
      }
      showMessage('Payment profile created successfully!', 'success');

      document.getElementById('submitCardOnFile').textContent="Success!";
      document.getElementById('cardOnFileModalText').textContent="Card added successfully! It may take a couple minutes for your card to appear in your profile.";
      await loadSessions();

      setTimeout(() => {
      const storedEmail = localStorage.getItem('playerEmail');
      initiateValidationFlowInBackground(storedEmail);
    }, 60000);

    } catch (err) {
      showMessage('Payment profile error: ' + err.message, 'error');
    }
  });

  async function initiateValidationFlowInBackground(email) {
    document.getElementById('mainNav').classList.remove('d-none');
    showMessage(`initiateValidationFlow for email: ${email}`, 'debug');

try {
  // 1) getPlayerInfo from GAS
  const playerUrl = `${GAS_PROXY}?action=getPlayerInfo&email=${encodeURIComponent(email)}`;
  const playerResp = await fetch(playerUrl);
  const playerData = await playerResp.json();
  showMessage(`playerData: ${JSON.stringify(playerData)}`, 'debug');

  if (!playerData.success || !playerData.player) {
    const welcomeModal = new bootstrap.Modal(document.getElementById('welcomeModal'));
    welcomeModal.show();
    showMessage(`Error retrieving or invalid player: ${playerData.error}`, 'error');
    showProfileSpinner(false);
    return;
  }
  currentPlayer = playerData.player;

  // 2) Check Stripe
  const stripeUrl = `${FIND_STRIPE_URL}?email=${encodeURIComponent(email)}`;
  const stripeResp = await fetch(stripeUrl);
  const stripeData = await stripeResp.json();
  showMessage(`stripeData: ${JSON.stringify(stripeData)}`, 'debug');

  if (!stripeData.success) {
    showMessage('Error checking Stripe: ' + (stripeData.error || ''), 'error');
    showProfileSpinner(false);
    return;
  }
  if (stripeData.exists) {
    currentPlayer.cardLast4 = stripeData.cardLast4 || null;
  } else {
    showMessage('No Stripe customer found => Payment Profile needed', 'debug');
  }

  // 3) Fetch user credit
  const creditUrl = `${GET_CREDIT_URL}&email=${encodeURIComponent(email)}`;
  const creditResp = await fetch(creditUrl);
  const creditData = await creditResp.json();
  showMessage(`creditData: ${JSON.stringify(creditData)}`, 'debug');
  currentPlayer.credit = creditData.success ? (creditData.credit || 0) : 0;

  // 4) Fetch membership from Firebase Realtime Database
  try {
    const dbRef = firebase.database().ref('subscriptions');
    // We'll read ALL subscriptions and find the one that matches currentPlayer.email
    const snapshot = await dbRef.once('value');
    const subsData = snapshot.val() || {};
    let membershipType = null;
    let membershipEnd = null;

    // We search for a record with .email === currentPlayer.email
    Object.keys(subsData).forEach(key => {
      const sub = subsData[key];
      if (sub && sub.email && sub.email.toLowerCase() === currentPlayer.email.toLowerCase()) {
        // Found a match
        if (sub.active) {
          membershipType = sub.membershipType || null;
          membershipEnd  = sub.endDate || null;
          membershipStart = sub.startDate || null;
        }
      }
    });

    
    currentPlayer.membershipType    = membershipType;
    currentPlayer.membershipEndDate = membershipEnd;
    currentPlayer.membershipStartDate = membershipStart;

    //Only members can use forum. This is anyone with an unexpired membership
    if (currentPlayer.membershipType) {
      const now = new Date();
      const endDate = new Date(membershipEnd);
      
      // Only show the forum link if membershipEnd is in the future
      if (endDate > now) {
        document.getElementById('home-link-forum').style.display = 'block';
      }
    }


    /* Only Allow Active Members to Use Forum
    if (currentPlayer.membershipType) {
      const now = new Date();
      const startDate = new Date(membershipStart);
      const endDate = new Date(membershipEnd);

      // Only show the forum link if today is between the start and end dates (inclusive)
      if (now >= startDate && now <= endDate) {
        document.getElementById('home-link-forum').style.display = 'block';
      }
    }
    */

    showMessage(`Membership found: type=${membershipType}, end=${membershipEnd}`, 'debug');
  } catch (firebaseErr) {
    showMessage('Error fetching membership from Firebase: ' + firebaseErr.message, 'error');
    currentPlayer.membershipType = null;
    currentPlayer.membershipEndDate = null;
    currentPlayer.membershipStartDate = null;
  }

  await fetchExistingFreeSlots(currentPlayer.email);

  // Show profile
  setProfileData(currentPlayer);

  updateMembershipMessage();

  // If no stripe => show modal
  if (!stripeData.exists && !document.referrer && !document.referrer.includes('subscription.html')) {
    const modalEl = new bootstrap.Modal(document.getElementById('paymentModal'));
    modalEl.show();
  } else {
    // Load sessions
  
    await loadSessions();
    
  }

  
} catch (err) {
  showMessage('initiateValidationFlow error: ' + err.message, 'error');

}
}

  /************************************************************
   * 7) LOAD SESSIONS -> DISPLAY AS CARDS
   ************************************************************/
  async function loadSessions() {
    showMessage('Loading sessions from getSessions', 'debug');
    try {
      const url = `${GAS_PROXY}?action=getSessions`;
      const resp = await fetch(url);
      const data = await resp.json();

      if (!data.success) {
        showMessage('Error loading sessions: ' + data.error, 'error');
        return;
      }
      const sessionInfos = data.sessions || [];
      // For each session, fetch programs
      const sessionPromises = sessionInfos.map(sess => fetchProgramsForSession(sess));
      const results = await Promise.all(sessionPromises);
      allSessions = results; 
      // Now display them as cards:
      displaySessionCards(allSessions);
    } catch (err) {
      showMessage('Session load error: ' + err.message, 'error');
    }
  }

  async function fetchProgramsForSession(sess) {
  const programUrl = `${GAS_PROXY}?action=getProgramList&sessionId=${encodeURIComponent(sess.spreadsheetId)}`;
  const resp = await fetch(programUrl);
  const data = await resp.json();
  if (!data.success) {
    showMessage('Error loading programs for ' + sess.spreadsheetId, 'error');
    return { ...sess, products: [] };
  }

  // Add a step to apply freeEligible based on discountMap
  const rawProducts = data.products || [];
  const updatedProducts = rawProducts.map(product => {
    const catConfig = discountMap[product.category] || {};
    // catConfig might look like: { freeEligible: true, tiers: { Gold: 1.0, ... } }
    product.freeEligible = !!catConfig.freeEligible;
    return product;
  });

  return {
    ...sess,
    products: updatedProducts
  };
}


/**
 * getDiscountedPrice (Option A) with logging
 *
 * Given a product (which already has .freeEligible set),
 * plus the current user's membership info, computes the final total price
 * after applying:
 *  - partial membership coverage per date,
 *  - one free slot per Monday–Sunday for Gold members (if .freeEligible = true).
 *
 * @param {Object} product                  - The product object (must have .price, .category, .program, and .freeEligible)
 * @param {string} membershipType           - e.g. "Gold", "Silver", or null
 * @param {string} membershipEndDate        - e.g. "2025-12-31" (parseable date)
 * @param {Object} ephemeralFreeSlotMap     - A global map tracking used free slots, e.g. { "2025-03-17": true, ... }
 * @returns {Object}                        - { total: number, usedWeeks: string[] }
 */
 function getDiscountedPrice(
  product, 
  membershipType, 
  membershipEndDate, 
  membershipStartDate, 
  ephemeralFreeSlotMap, 
  options = {}
) {
  const readOnly = options.readOnly === true;

  console.log('[getDiscountedPrice] START readOnly=', readOnly);
  console.log('  product:', product);
  console.log('  membershipType:', membershipType);
  console.log('  membershipStartDate:', membershipStartDate);
  console.log('  membershipEndDate:', membershipEndDate);
  console.log('  ephemeralFreeSlotMap (partial):', JSON.stringify(ephemeralFreeSlotMap, null, 2));

  // 1) Basic checks
  const basePrice = product.price || 0;
  const allDates = parseAllDates(product.program);
  console.log('  Parsed', allDates.length, 'date(s) from program:', product.program);

  if (!allDates.length) {
    // Fallback if no valid dates are parsed
    console.log('  No valid dates parsed; returning basePrice:', basePrice);
    return { total: basePrice, usedWeeks: [] };
  }

  // If no membership or no valid membership window, user pays full
  if (!membershipType || !membershipEndDate || !membershipStartDate) {
    console.log('  Missing membershipType/startDate/endDate => returning full price:', basePrice);
    return { total: basePrice, usedWeeks: [] };
  }

  // Convert membership start/end strings to Date objects
  const startDate = new Date(membershipStartDate);
  const endDate   = new Date(membershipEndDate);

  // If membershipEndDate is in the past, full price
  if (endDate < new Date()) {
    console.log('  Membership endDate is in the past => returning full price:', basePrice);
    return { total: basePrice, usedWeeks: [] };
  }

  // 2) Determine membership discount factor from discountMap
  const catMap = discountMap[product.category] || {};
  // e.g. catMap = { freeEligible: true, Gold: 0.2, Silver: 0.2 }
  // If catMap[membershipType] is undefined => 0 discount
  const membershipDiscountFactor = catMap[membershipType] || 0;

  console.log(`  Category: "${product.category}", discountFactor for ${membershipType}:`, membershipDiscountFactor);
  console.log('  product.freeEligible:', product.freeEligible);

  // 3) Prepare to iterate day-by-day
  const slicePrice = basePrice / allDates.length;
  console.log('  slicePrice:', slicePrice, '(basePrice / # of dates)');

  let total = 0;
  let usedWeeks = [];

  // Sort dates ascending
  allDates.sort((a, b) => a - b);

  // 4) For each date, decide if we apply free slot or partial discount
  for (let i = 0; i < allDates.length; i++) {
    const dateObj = allDates[i];
    const dateStr = dateObj.toLocaleDateString();
    console.log(`  Checking date #${i + 1}: ${dateStr}`);

    // If date is before membershipStart or after membershipEnd => full price
    if (dateObj < startDate || dateObj > endDate) {
      console.log(`    Date ${dateStr} is outside membership window => pay full (${slicePrice})`);
      total += slicePrice;
      continue;
    }

    // Within the membership window
    let finalSliceCost;
    if (membershipType === 'Gold' && product.freeEligible) {
      const monday = getMondayOfWeek(dateObj);
      const weekKey = toYMDString(monday);

      // If readOnly => do NOT consume the slot
      if (!readOnly && !ephemeralFreeSlotMap[weekKey]) {
        // Mark the slot used
        ephemeralFreeSlotMap[weekKey] = true;
        finalSliceCost = 0;
        usedWeeks.push(weekKey);
        console.log(`    Free slot used (weekKey=${weekKey}). finalSliceCost=0`);
      } else if (!readOnly && ephemeralFreeSlotMap[weekKey]) {
        // Already used the slot
        finalSliceCost = slicePrice * (1 - membershipDiscountFactor);
        console.log(`    Slot already used => discount price=${finalSliceCost}`);
      } else {
        // readOnly == true => simulate without consuming
        const isAlreadyUsed = ephemeralFreeSlotMap[weekKey] === true;
        if (!isAlreadyUsed) {
          // Show 0 for display
          finalSliceCost = 0;
          console.log(`    readOnly => free slot (unused) => finalSliceCost=0`);
        } else {
          finalSliceCost = slicePrice * (1 - membershipDiscountFactor);
          console.log(`    readOnly => free slot (used) => discount price=${finalSliceCost}`);
        }
      }
    } else {
      // Not Gold or not freeEligible => membership discount
      finalSliceCost = slicePrice * (1 - membershipDiscountFactor);
      console.log(`    Normal membership discount => ${finalSliceCost}`);
    }

    total += finalSliceCost;
  }

  // 5) Round to 2 decimals
  total = Math.floor(total * 100) / 100;
  console.log('  FINAL total:', total);
  console.log('  usedWeeks:', usedWeeks);
  console.log('[getDiscountedPrice] END\n');

  // Return final cost + which weeks were used
  return { total, usedWeeks };
}



function displaySessionCards(sessions) {
const container = document.getElementById('session-cards');
container.innerHTML = '';

if (!sessions || !sessions.length) {
  container.innerHTML = '<p>No sessions found.</p>';
  return;
}

// Simply loop through sessions in their original order
sessions.forEach(sessionObj => {
    // Skip card if location contains "Galloway" or "Atlantic"
    if (sessionObj.location.includes('Galloway') || sessionObj.location.includes('Atlantic')) {
    return;
  }
  const label = `${sessionObj.location} - ${sessionObj.season}`;

  // Create a column for each session
  const colDiv = document.createElement('div');
  colDiv.classList.add('col-12','col-sm-6','col-md-4','col-lg-3','mb-3');

  // Card wrapper
  const cardDiv = document.createElement('div');
  cardDiv.className = 'card session-card h-100'; 
  // If it's the currently selected session, highlight it
  if (selectedSession && sessionObj.spreadsheetId === selectedSession.spreadsheetId) {
    cardDiv.classList.add('selected-session');
  }

  // Card body
  const cardBody = document.createElement('div');
  cardBody.className = 'card-body';

  // Title
  const titleEl = document.createElement('h6');
  titleEl.classList.add('card-title','mb-2');
  titleEl.textContent = label;

  // Button
  const selectBtn = document.createElement('button');
  selectBtn.classList.add('btn','btn-sm');
  if (selectedSession && sessionObj.spreadsheetId === selectedSession.spreadsheetId) {
    selectBtn.textContent = 'Selected';
    selectBtn.classList.add('btn-success');
  } else {
    selectBtn.textContent = 'Select';
    selectBtn.classList.add('btn-primary');
  }

  // Handle click => set selectedSession, then re-display
  selectBtn.addEventListener('click', () => {
    // Update selectedSession first
    selectedSession = sessionObj;
    
    // Re-render the session cards to highlight the new selection
    displaySessionCards(sessions);

    // Use the new onSessionSelected function
    onSessionSelected(sessionObj);

    // Hide the old filter groups that we're not using anymore
    document.getElementById('category-filter-group').style.display = 'none';
    document.getElementById('level-filter-group').style.display = 'none';
    document.getElementById('daytime-filter-group').style.display = 'none';
  });

  // Assemble the card
  cardBody.appendChild(titleEl);
  cardBody.appendChild(selectBtn);
  cardDiv.appendChild(cardBody);
  colDiv.appendChild(cardDiv);
  container.appendChild(colDiv);
});

if (!currentPlayer?.membershipType) {
 // Add the "Purchase a Membership!" card
 const purchaseCol = document.createElement('div');
  purchaseCol.classList.add('col-12', 'col-sm-6', 'col-md-4', 'col-lg-3', 'mb-3');

  const purchaseCard = document.createElement('div');
  purchaseCard.className = 'card session-card h-100';

  const purchaseBody = document.createElement('div');
  purchaseBody.className = 'card-body';

  const purchaseTitle = document.createElement('h6');
  purchaseTitle.classList.add('card-title', 'mb-2');
  purchaseTitle.textContent = 'Purchase a Membership (memberships are not required, but help you play more and spend less)!';

  const purchaseBtn = document.createElement('button');
  purchaseBtn.classList.add('btn', 'btn-sm', 'btn-warning');
  purchaseBtn.textContent = 'Purchase';

  purchaseBtn.addEventListener('click', (e) => {
    e.preventDefault();
    window.location.href = 'subscription.html';
  });

  purchaseBody.appendChild(purchaseTitle);
  purchaseBody.appendChild(purchaseBtn);
  purchaseCard.appendChild(purchaseBody);
  purchaseCol.appendChild(purchaseCard);
  container.appendChild(purchaseCol);
}

}



  /************************************************************
   * 8) FILTERS => PROGRESSIVE
   ************************************************************/
  function showFilterStep(step) {
    const filterSection = document.getElementById('filter-section');
    const catGroup      = document.getElementById('category-filter-group');
    const lvlGroup      = document.getElementById('level-filter-group');
    const dtGroup       = document.getElementById('daytime-filter-group');
    const progContainer = document.getElementById('program-cards-container');

    if (step === 0) {
      // We comment out hiding the entire filterSection to keep the toggle visible
      // filterSection.style.display  = 'none'; 
      catGroup.style.display       = 'none';
      lvlGroup.style.display       = 'none';
      dtGroup.style.display        = 'none';
      progContainer.style.display  = 'none';
      return;
    }

    filterSection.style.display = 'block';
    if (step === 1) {
      catGroup.style.display      = 'block';
      lvlGroup.style.display      = 'none';
      dtGroup.style.display       = 'none';
      progContainer.style.display = 'none';
    } else if (step === 2) {
      lvlGroup.style.display      = 'block';
      dtGroup.style.display       = 'none';
      progContainer.style.display = 'none';
    } else if (step === 3) {
      dtGroup.style.display       = 'block';
      progContainer.style.display = 'none';
    } else if (step === 4) {
      // Only show program cards if day/time is selected
      progContainer.style.display = 'flex';
    }
  }

  function resetProductFilters() {
    selectedCategory = null;
    selectedLevel    = null;
    selectedDayTime  = null;
    selectedStandardizedLevel = null;


    const catSelect = document.getElementById('category-filter');
    catSelect.innerHTML = '<option value="">--Select a Category--</option>';

    if (!allProducts.length) {
      showFilterStep(0);
      return;
    }

    // Populate categories
    const categories = [...new Set(allProducts.map(p => p.category).filter(Boolean))];
    categories.forEach(cat => {
      const opt = document.createElement('option');
      opt.value = cat;
      opt.textContent = cat;
      catSelect.appendChild(opt);
    });

    document.getElementById('level-filter').innerHTML    = '<option value="">--Select a Level--</option>';
    document.getElementById('daytime-filter').innerHTML  = '<option value="">--Select a Day/Time--</option>';

    showFilterStep(1);
  }

  document.getElementById('category-filter').addEventListener('change', () => {
    selectedCategory = document.getElementById('category-filter').value.trim();
    let filtered = selectedCategory
      ? allProducts.filter(p => p.category === selectedCategory)
      : allProducts;

    document.getElementById('program-cards-container').innerHTML = '';
    document.getElementById('program-cards-container').style.display = 'none';

    const levelSelect = document.getElementById('level-filter');
    levelSelect.innerHTML = '<option value="">--Select a Level--</option>';
    const levels = [...new Set(filtered.map(p => p.level).filter(Boolean))];
    levels.forEach(lv => {
      const opt = document.createElement('option');
      opt.value = lv;
      opt.textContent = lv;
      levelSelect.appendChild(opt);
    });
    showFilterStep(2);
  });

  document.getElementById('level-filter').addEventListener('change', () => {
    selectedLevel = document.getElementById('level-filter').value.trim();

    document.getElementById('program-cards-container').innerHTML = '';
    document.getElementById('program-cards-container').style.display = 'none';

    let filtered = allProducts;
    if (selectedCategory) filtered = filtered.filter(p => p.category === selectedCategory);
    if (selectedLevel)    filtered = filtered.filter(p => p.level === selectedLevel);

    // populate day/time
    const dtSelect = document.getElementById('daytime-filter');
    dtSelect.innerHTML = '<option value="">--Select a Day/Time--</option>';
    const dayTimes = [...new Set(filtered.map(p => p.dayTime).filter(Boolean))];
    dayTimes.forEach(dt => {
      const opt = document.createElement('option');
      opt.value = dt;
      opt.textContent = dt;
      dtSelect.appendChild(opt);
    });
    showFilterStep(3);
  });

  document.getElementById('daytime-filter').addEventListener('change', () => {
    selectedDayTime = document.getElementById('daytime-filter').value.trim();
    renderProgramCards();
    showFilterStep(4);
  });

  function renderProgramCards() {
  const container = document.getElementById('program-cards-container');
  container.innerHTML = '';

  let filtered = allProducts;
  if (selectedCategory) filtered = filtered.filter(p => p.category === selectedCategory);
  if (selectedLevel)    filtered = filtered.filter(p => p.level === selectedLevel);
  if (selectedDayTime)  filtered = filtered.filter(p => p.dayTime === selectedDayTime);

  if (!filtered.length) {
    container.innerHTML = '<p>No programs match these filters.</p>';
    return;
  }

  filtered.forEach(prod => {
    const cardDiv = document.createElement('div');
    cardDiv.className = 'program-card';

    // Check if this product is already in the cart
    const cartItem = cartItems.find(ci => ci.program === prod.program && ci.sessionId === selectedSession.spreadsheetId);
    const inCart   = !!cartItem;
    if (inCart) {
      cardDiv.classList.add('added');
    }

    const nameEl = document.createElement('div');
    nameEl.className = 'program-name';
    nameEl.textContent = prod.program;

    const priceEl = document.createElement('div');
    priceEl.className = 'program-price';

    // === MEMBERSHIP PRICE LOGIC (read-only vs. locked-in cart price) ===
    let displayPrice = 0;

    if (inCart) {
      // If the item is already in the cart, show the "locked-in" price
      displayPrice = cartItem.price;
    } else {
      // Otherwise, do a read-only price calculation so we don't consume another free slot
      const { total: readOnlyPrice } = getDiscountedPrice(
        prod,
        currentPlayer?.membershipType,
        currentPlayer?.membershipEndDate,
        currentPlayer?.membershipStartDate,
        freeSlotUsageMap,
        { readOnly: true } // <== KEY: does not consume the free slot
      );
      displayPrice = readOnlyPrice;
    }

    var pct2 = 0;

    // Format the display price
    const basePrice   = prod.price || 0;
    let label = `$${displayPrice.toFixed(2)}`;
    if (displayPrice < basePrice) {
      // A discount was applied
      const catMap = discountMap[prod.category] || {};
      const discountFactor = catMap[currentPlayer?.membershipType] || 0;
      const pct = Math.round(discountFactor * 100);
      pct2 = pct;
      //label += ` (${pct}% discount)`;
      // label += ` (Member Benefit Applied)`;
    }
    priceEl.textContent = label;
    // === END MEMBERSHIP PRICE LOGIC ===

    const badgesEl = document.createElement('div');
    badgesEl.className = 'badges';
    const catBadge = document.createElement('span');
    catBadge.className = 'badge bg-primary me-2';
    catBadge.textContent = prod.category || 'N/A';

    const levelBadge = document.createElement('span');
    levelBadge.className = 'badge bg-info';
    levelBadge.textContent = prod.level || 'N/A';

    badgesEl.appendChild(catBadge);
    badgesEl.appendChild(levelBadge);

    if (prod.indoorOutdoor) {
      const ioBadge = document.createElement('span');
      ioBadge.className = 'badge bg-secondary';
      ioBadge.textContent = prod.indoorOutdoor;
      badgesEl.appendChild(ioBadge);
    }

    const addBtn = document.createElement('button');
    addBtn.className = 'btn btn-sm btn-success btn-add';
    if (displayPrice == 0) {
      addBtn.textContent = `Add to Cart (Free)`;
    } else if (nameEl.textContent.includes('Package') && displayPrice < basePrice){
      addBtn.textContent = `Add to Cart (Member Discount)`;
    } else if (nameEl.textContent.includes('Package')){
      addBtn.textContent = `Add to Cart`;
    } else if (pct2 > 0) {
    addBtn.textContent = `Add to Cart (${pct2}% Off)`;
    } else {
      addBtn.textContent = `Add to Cart`;
    }
    if (prod.soldOut) {
      addBtn.disabled = true;
      nameEl.innerHTML = `<s>${prod.program}</s> (Sold Out)`;
    }
    addBtn.addEventListener('click', () => {
  // 1) Actually add the product to the cart
  addProductToCart(prod);
  cardDiv.classList.add('added');
  updateProgramCardState(cardDiv, prod);

  // 2) If user is a member and this product is a "Package," check for partial coverage
  if (currentPlayer?.membershipType && prod.program.includes('Package')) {
    // 3) Parse all the program's dates
    const allDates = parseAllDates(prod.program);
    if (!allDates.length) return; // Can't parse => do nothing

    // 4) Compare each date to membershipEndDate
    const membershipEnd = new Date(currentPlayer?.membershipEndDate || '');
    if (isNaN(membershipEnd.getTime())) return; // invalid date => do nothing

    // If ANY date is beyond membership coverage => at least one day is full price
    const hasFullPriceDay = allDates.some(dateObj => dateObj > membershipEnd);

    if (hasFullPriceDay) {
      // 5) Trigger your existing modal (renamed or the same ID)
      const alertModalEl = new bootstrap.Modal(document.getElementById('creditAlertModal'));
      alertModalEl.show();
    }
  }
});

    const addedControls = document.createElement('div');
    addedControls.className = 'added-controls';
    addedControls.innerHTML = `
      <span class="text-success"><strong>&check;</strong> Added</span>
      <button class="btn btn-sm btn-outline-danger ms-2">Remove</button>
    `;
    const removeBtn = addedControls.querySelector('button');
    removeBtn.addEventListener('click', () => {
      removeProductFromCart(prod, selectedSession.spreadsheetId);
      cardDiv.classList.remove('added');
      updateProgramCardState(cardDiv, prod);
    });

    cardDiv.appendChild(nameEl);
    cardDiv.appendChild(priceEl);
    cardDiv.appendChild(badgesEl);
    cardDiv.appendChild(addBtn);
    cardDiv.appendChild(addedControls);

    // Existing logic: if price == basePrice and user has a membership, suggest "Pre-Extend Membership"
    if (displayPrice == basePrice && currentPlayer?.membershipType) {
      const extndBtn = document.createElement('button');
      extndBtn.className = 'btn btn-xs btn-danger btn-add';
      extndBtn.textContent = 'Extend Your Membership';
      extndBtn.addEventListener('click', () => {
        window.location.href = 'subscription.html';
      });
      priceEl.insertAdjacentElement('afterend', extndBtn);
    }



    container.appendChild(cardDiv);
  });
}




function getMondayOfWeek(d) {
  // clone d to avoid mutating the original
  const date = new Date(d);
  const day = date.getDay();
  // day: 0=Sun, 1=Mon, 2=Tue, ...
  const diff = day === 0 ? 6 : (day - 1);
  // if it's Sunday (day=0), we treat that as the last day of the prior week,
  // so we go back 6 days to reach Monday
  date.setDate(date.getDate() - diff);
  // Now 'date' is the Monday of that week
  return new Date(date.getFullYear(), date.getMonth(), date.getDate());
}

function toYMDString(d) {
  // For storing in the map
  let mm = (d.getMonth()+1).toString().padStart(2,'0');
  let dd = d.getDate().toString().padStart(2,'0');
  return `${d.getFullYear()}-${mm}-${dd}`;

}

function updateProgramCardState(cardDiv, prod) {
    const inCart = cartItems.find(ci => ci.program === prod.program && ci.sessionId === selectedSession.spreadsheetId);
    if (inCart) {
      cardDiv.classList.add('added');
    } else {
      cardDiv.classList.remove('added');
    }
  }

  /************************************************************
   * 8b) AutoPopulate Filter Logic from Calendar View
   ************************************************************/


  function autoPopulateFilters(autoCategory, autoLevel, autoDayTime) {
  // 1. Reset filters and repopulate the category options
  //resetProductFilters();

  // 2. Set the category filter value and trigger its change event
  const catSelect = document.getElementById('category-filter');
  if (autoCategory && Array.from(catSelect.options).some(opt => opt.value === autoCategory)) {
    catSelect.value = autoCategory;
  } else {
    catSelect.value = ""; // Default to "--Select a Category--"
  }
  catSelect.dispatchEvent(new Event('change'));

  // 3. Set the level filter value and trigger its change event
  const lvlSelect = document.getElementById('level-filter');
  if (autoLevel && Array.from(lvlSelect.options).some(opt => opt.value === autoLevel)) {
    lvlSelect.value = autoLevel;
  } else {
    lvlSelect.value = ""; // Default to "--Select a Level--"
  }
  lvlSelect.dispatchEvent(new Event('change'));

  // 4. Set the day/time filter value and trigger its change event to render program cards
  const dtSelect = document.getElementById('daytime-filter');
  if (autoDayTime && Array.from(dtSelect.options).some(opt => opt.value === autoDayTime)) {
    dtSelect.value = autoDayTime;
  } else {
    dtSelect.value = ""; // Default to "--Select a Day/Time--"
  }
  dtSelect.dispatchEvent(new Event('change'));
}


  /************************************************************
   * 9) CART LOGIC
   ************************************************************/
/**
 * addProductToCart
 * 
 * Adds the given product to cartItems, computing the discounted price (including potential free slot).
 * Also tracks which weekly slots were used for that product so we can remove them if the product is taken out of the cart.
 */
 function addProductToCart(product) {
  if (!selectedSession) return;
  const sessionId = selectedSession.spreadsheetId;

  // Check if already in cart
  const existing = cartItems.find(
    (ci) => ci.program === product.program && ci.sessionId === sessionId
  );
  if (existing) {
    return;
  }

  // Use the new getDiscountedPrice function
  const { total, usedWeeks } = getDiscountedPrice(
    product,
    currentPlayer?.membershipType,
    currentPlayer?.membershipEndDate,
    currentPlayer?.membershipStartDate,
    freeSlotUsageMap, 
    { readOnly: false }
  );

  // Add to cartItems array
  cartItems.push({
    sessionId: sessionId,
    program: product.program,
    category: product.category,
    level: product.level,
    price: total,
    sessionLabel: `${selectedSession.location} - ${selectedSession.season}`,
    freeWeeksUsed: usedWeeks,
    indoorOutdoor: product.indoorOutdoor
  });

  // Update cart UI without affecting program display
  updateCartTable();
  
  // Instead of re-rendering everything, just update the specific card
  const { selectedLevels, selectedCategories } = getSelectedFilters();
  const shouldShowProduct = (!selectedLevels.length || product.standardizedLevelList?.some(level => selectedLevels.includes(level))) &&
                          (!selectedCategories.length || selectedCategories.includes(product.category));
  
  if (shouldShowProduct) {
    // Find and update the specific card
    const cards = document.querySelectorAll('.program-card');
    cards.forEach(card => {
      const nameEl = card.querySelector('.program-name');
      if (nameEl && nameEl.textContent === product.program) {
        card.classList.add('added');
        
        // Update add button to show "Added" state
        const addBtn = card.querySelector('.btn-add');
        if (addBtn) addBtn.style.display = 'none';
        
        // Show remove controls
        const addedControls = card.querySelector('.added-controls');
        if (addedControls) addedControls.style.display = 'block';
      }
    });
  }
}



/**
 * removeProductFromCart
 * 
 * Removes a product from the cart and "frees up" any weekly slots that had been used by it.
 */
 function removeProductFromCart(product, sessionId) {
  const idx = cartItems.findIndex(
    (ci) => ci.program === product.program && ci.sessionId === sessionId
  );
  if (idx > -1) {
    const removedItem = cartItems[idx];
    // Free up any weeks used:
    if (removedItem.freeWeeksUsed && Array.isArray(removedItem.freeWeeksUsed)) {
      for (let weekKey of removedItem.freeWeeksUsed) {
        freeSlotUsageMap[weekKey] = false;
      }
    }
    cartItems.splice(idx, 1);
  }
  
  // Update cart UI without affecting program display
  updateCartTable();
  
  // Instead of re-rendering everything, just update the specific card
  const { selectedLevels, selectedCategories } = getSelectedFilters();
  const shouldShowProduct = (!selectedLevels.length || product.standardizedLevelList?.some(level => selectedLevels.includes(level))) &&
                          (!selectedCategories.length || selectedCategories.includes(product.category));
  
  if (shouldShowProduct) {
    // Find and update the specific card
    const cards = document.querySelectorAll('.program-card');
    cards.forEach(card => {
      const nameEl = card.querySelector('.program-name');
      if (nameEl && nameEl.textContent === product.program) {
        card.classList.remove('added');
        
        // Show add button again
        const addBtn = card.querySelector('.btn-add');
        if (addBtn) addBtn.style.display = 'block';
        
        // Hide remove controls
        const addedControls = card.querySelector('.added-controls');
        if (addedControls) addedControls.style.display = 'none';
      }
    });
  }
}



  function updateCartTable() {
    const tbody = document.querySelector('#cart-table tbody');
    const cartSection = document.getElementById('cart-section');
    const amountDueLine = document.getElementById('amount-due-line');
    const breakdownLine = document.getElementById('breakdown-line');

    if (!tbody || !cartSection || !amountDueLine || !breakdownLine) return;

    tbody.innerHTML = '';
    if (cartItems.length === 0) {
      cartSection.style.display = 'none';
      amountDueLine.textContent = '';
      breakdownLine.textContent = '';
      updateCartSummaryPill();
      return;
    }
    cartSection.style.display = 'block';

    cartItems.forEach((item, idx) => {
      const tr = document.createElement('tr');
      let tdProg = document.createElement('td');
      tdProg.innerHTML = `
        <div>${item.program}</div>
        <div class="mt-1">
          <span class="badge bg-primary me-1">${item.category || 'N/A'}</span>
          <span class="badge bg-secondary">${item.level || 'N/A'}</span>
        </div>
      `;
      tr.appendChild(tdProg);

      let tdSession = document.createElement('td');
      tdSession.textContent = item.sessionLabel;
      tr.appendChild(tdSession);

      let tdRemove = document.createElement('td');
      let btnRemove = document.createElement('button');
      btnRemove.className = 'btn btn-sm btn-danger';
      btnRemove.textContent = 'Remove';
      btnRemove.onclick = () => {
        removeProductFromCart(cartItems[idx], cartItems[idx].sessionId);
      };
      tdRemove.appendChild(btnRemove);
      tr.appendChild(tdRemove);

      tbody.appendChild(tr);
    });

    // Compute raw total
    const totalCents = calculateCartTotalCents();
    const programTotal = totalCents / 100;

    // Subtract credit
    const credit = currentPlayer?.credit || 0;
    let creditUsed = (credit >= programTotal) ? programTotal : credit;
    let amountDue = programTotal - creditUsed;

    amountDueLine.textContent = `Amount Due: $${amountDue.toFixed(2)}`;
    breakdownLine.textContent = `Program Total: $${programTotal.toFixed(2)} | Credit Balance: $${credit.toFixed(2)}`;

    updateCartSummaryPill();

    if (!currentPlayer.cardLast4) {
      document.getElementById('btn-charge-on-file').style.display = 'none';
    }

    if (totalCents == 0 || amountDue == 0) {
      document.getElementById('btn-charge-on-file').textContent = 'Submit Registration (No Charge)';
      document.getElementById('btn-charge-on-file').style.display = 'block';
      document.getElementById('btn-credit-debit').style.display = 'none';
    } else {
      document.getElementById('btn-charge-on-file').textContent = 'Charge Card On File';
      document.getElementById('btn-credit-debit').style.display = 'block';
    }

    const partnerNameDiv = document.getElementById('partnerName');
    if (cartItems.some(item => item.program.includes("Showdown"))) {
      partnerNameDiv.style.display = "block";
    } else {
      partnerNameDiv.style.display = "none";
    }
  }

  function updateCartSummaryPill() {
    const pill = document.getElementById('cart-summary-pill');
    const totalCents = calculateCartTotalCents();
    const total = (totalCents / 100).toFixed(2);

    if (cartItems.length === 0) {
      pill.style.display = 'none';
      return;
    }
    pill.style.display = 'block';
    pill.textContent = `Checkout ${cartItems.length} item(s) - $${total}`;
  }

  function calculateCartTotalCents() {
    let total = 0;
    cartItems.forEach(item => {
      total += (item.price || 0);
    });
    return total * 100;
  }

  async function chargeCart(email, amountInCents) {
    showMessage(`Charging cart: Email=${email}, Amount=${amountInCents} cents`, 'debug');
    if (amountInCents <= 0) {
      return true; 
    }
    try {
      const payload = { email, amount: amountInCents };
      const resp = await fetch(CHARGE_CART_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data = await resp.json();
      if (data.success) {
        showMessage('Payment succeeded in chargeCart.', 'info');
        return true;
      } else {
        showMessage('Payment failed: ' + (data.error || ''), 'error');
        return false;
      }
    } catch (err) {
      showMessage('Network error charging cart: ' + err.message, 'error');
      return false;
    }
  }

  /************************************************************
   * Payment Buttons
   ************************************************************/
  document.getElementById('btn-charge-on-file').addEventListener('click', async () => {
    if (cartItems.length === 0) {
      showMessage('Cart is empty.', 'error');
      return;
    }
    showPaymentSuccess(false);
    showPaymentSpinner(true);

    const totalCents = calculateCartTotalCents();
    const programTotal = totalCents / 100;
    const credit = currentPlayer?.credit || 0;
    let creditRemaining = credit - programTotal;
    let creditUsed = (credit >= programTotal) ? programTotal : credit;
    let amountDue  = programTotal - creditUsed;
    let amountDueCents = Math.round(amountDue * 100);

    const email = currentPlayer.email;
    const success = await chargeCart(email, amountDueCents);
    if (!success) {
      showMessage('Payment failed, not registering.', 'error');
      showPaymentSpinner(false);
      return;
    }

    // register
    showMessage('Payment succeeded (or $0 due), now registering items...', 'info');
    await submitCartToSpreadsheet(creditUsed);
    showMessage('Successfully registered after payment!', 'success');
    
    // Calculate remaining credit
    if (creditRemaining > 0) {
      creditRemaining = creditRemaining;
    } else {
      creditRemaining = 0;
    }

    // Store cart items before clearing
    const registeredPrograms = [...cartItems];
    
    // Show the success modal with registered programs
    showSuccessModal(registeredPrograms, creditRemaining);

    // Clear cart and update UI
    cartItems = [];
    updateCartTable();
    showPaymentSpinner(false);
    showPaymentSuccess(true);

    await recordFreeSlotUsage();

    if (creditRemaining > 0) {
      creditRemaining = creditRemaining;
    } else {
      creditRemaining = 0;
    }

    if (creditUsed > 0) {
      const paySuccessBox = document.getElementById('payment-success');
      if (paySuccessBox) {
        paySuccessBox.innerHTML = `
          Payment processed successfully! Your registration has been submitted.<br/>
          You have $${creditRemaining.toFixed(2)} credit left.
        `;
      }
    }

  });

  document.getElementById('btn-credit-debit').addEventListener('click', () => {
    if (cartItems.length === 0) {
      alert('Cart is empty.');
      return;
    }
    const modalEl = new bootstrap.Modal(document.getElementById('oneTimePaymentModal'));
    modalEl.show();
  });

  document.getElementById('one-time-payment-form').addEventListener('submit', async (e) => {
e.preventDefault();
document.getElementById('otpf-card-errors').textContent = '';

document.getElementById('oneTimeSubmitBtn').textContent = 'Processing...';
document.getElementById('oneTimeSubmitBtn').disabled=true;

const nameOnCard = document.getElementById('otpf-name').value.trim();
if (!nameOnCard) {
  document.getElementById('otpf-card-errors').textContent = 'Name is required.';
  return;
}

// Create PaymentMethod
const { paymentMethod, error } = await stripe.createPaymentMethod({
  type: 'card',
  card: oneTimeCard,
  billing_details: {
    name: nameOnCard,
    email: currentPlayer?.email || ''
  }
});
if (error) {
  document.getElementById('otpf-card-errors').textContent = error.message;
  return;
}
showPaymentSpinner(true);

const totalCents   = calculateCartTotalCents();
const programTotal = totalCents / 100;
const credit       = currentPlayer?.credit || 0;
let creditRemaining = programTotal - credit;
let creditUsed     = (credit >= programTotal) ? programTotal : credit; 
let amountDue      = programTotal - creditUsed;
let amountDueCents = Math.round(amountDue * 100);

// If there's nothing to charge, skip Stripe PaymentIntent
if (amountDueCents <= 0) {
  // Register user in Sheets, update credit, etc.
  await registerAndCleanup(creditUsed);

  // Calculate remaining credit
  if (creditRemaining > 0) {
    creditRemaining = creditRemaining;
  } else {
    creditRemaining = 0;
  }

  // Store cart items before clearing
  const registeredPrograms = [...cartItems];
  
  // Show the success modal with registered programs
  showSuccessModal(registeredPrograms, creditRemaining);

  // If user wants to save card on file
  const saveCardCheckbox = document.getElementById('save-card-checkbox');
  if (saveCardCheckbox && saveCardCheckbox.checked) {
    try {
      await attachPaymentMethodToUser(paymentMethod.id);
    } catch (err) {
      console.error('Error saving card on file (zero due):', err);
    }
  }

  showPaymentSpinner(false);
  return;
}

// Call one-time function to create PaymentIntent
const payload = {
  amount: amountDueCents,
  paymentMethodId: paymentMethod.id
};
let clientSecret;
try {
  const resp = await fetch('https://merry-rugelach-c028d1.netlify.app/.netlify/functions/chargeOneTime', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  const data = await resp.json();
  if (!data.success) {
    throw new Error(data.error || 'Failed to create PaymentIntent.');
  }
  clientSecret = data.clientSecret;
} catch (err) {
  showPaymentSpinner(false);
  document.getElementById('otpf-card-errors').textContent = err.message;
  return;
}

try {
  // Confirm the PaymentIntent on the frontend
  const confirmResult = await stripe.confirmCardPayment(clientSecret);
  if (confirmResult.error) {
    showPaymentSpinner(false);
    document.getElementById('otpf-card-errors').textContent = confirmResult.error.message;
    return;
  }
  if (confirmResult.paymentIntent && confirmResult.paymentIntent.status === 'succeeded') {
    // Registration flow, minus credit used
    await registerAndCleanup(creditUsed);

    // Calculate remaining credit
    if (creditRemaining > 0) {
      creditRemaining = creditRemaining;
    } else {
      creditRemaining = 0;
    }

    // Store cart items before clearing
    const registeredPrograms = [...cartItems];
    
    // Show the success modal with registered programs
    showSuccessModal(registeredPrograms, creditRemaining);

    // If user wants to save card on file
    const saveCardCheckbox = document.getElementById('save-card-checkbox');
    if (saveCardCheckbox && saveCardCheckbox.checked) {
      try {
        await attachPaymentMethodToUser(paymentMethod.id);
      } catch (err) {
        console.error('Error saving card on file:', err);
      }
    }
    showPaymentSpinner(false);
  } else {
    showPaymentSpinner(false);
    document.getElementById('otpf-card-errors').textContent = 'Payment not completed.';
  }
} catch (err) {
  showPaymentSpinner(false);
  document.getElementById('otpf-card-errors').textContent = err.message;
}
document.getElementById('oneTimeSubmitBtn').disabled=false;
});

/**
* Attaches the given PaymentMethod to the current user's Stripe Customer.
* Reuses your 'createStripe' logic or similar endpoint that handles "find or create" logic.
*/
async function attachPaymentMethodToUser(paymentMethodId) {
if (!currentPlayer || !currentPlayer.email) {
  console.error('Cannot attach PaymentMethod; no currentPlayer or email available.');
  return;
}

const payload = {
  email: currentPlayer.email,
  paymentMethodId: paymentMethodId,
  name: (currentPlayer.firstName || '') + ' ' + (currentPlayer.lastName || '')
};

try {
  const resp = await fetch(CREATE_STRIPE_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  const data = await resp.json();
  if (!data.success) {
    console.error('Error attaching PaymentMethod to user:', data.error);
  } else {
    console.log("Successfully attached card to user's Stripe account");
    // Update local data so we know they have a card on file
    currentPlayer.cardLast4 = data.cardLast4 || '****';
  }
} catch (err) {
  console.error('Network error in attachPaymentMethodToUser:', err);
}
}


/**
 * registerAndCleanup
 * 
 * 1) Registers the items in the spreadsheet (submitCartToSpreadsheet).
 * 2) Records free slot usage in Firebase (so user can't re-use that free slot in a separate checkout).
 * 3) Clears cart and closes spinner/UI.
 */
 async function registerAndCleanup(creditUsed) {
  // Step 1: Register the cart items in your Sheets (already existing logic).
  await submitCartToSpreadsheet(creditUsed);

  // Step 2: Record free slot usage in Firebase, so future checkouts can't re-use them.
  await recordFreeSlotUsage();

  // Step 3: Clear the cart and update UI
  cartItems = [];
  updateCartTable();
  showPaymentSpinner(false);
  showPaymentSuccess(true);

  // Hide modal if needed
  const modalEl = bootstrap.Modal.getInstance(document.getElementById('oneTimePaymentModal'));
  if (modalEl) {
    modalEl.hide();
  }
}

/**
 * recordFreeSlotUsage
 * 
 * Writes all used week keys in `freeSlotUsageMap` to Firebase under `freeSlotUsage/[emailKey]/[weekKey]`.
 * Then resets `freeSlotUsageMap` to empty. 
 * 
 * Only relevant for Gold members.
 */
 async function recordFreeSlotUsage() {
  console.log('[recordFreeSlotUsage] START');
  console.log('[recordFreeSlotUsage] currentPlayer =', currentPlayer);
  console.log('[recordFreeSlotUsage] ephemeral freeSlotUsageMap BEFORE =', JSON.stringify(freeSlotUsageMap, null, 2));

  // If user is not Gold or currentPlayer is missing, skip and clear the map
  if (!currentPlayer || currentPlayer.membershipType !== 'Gold') {
    console.log('[recordFreeSlotUsage] User is not Gold or missing currentPlayer => clearing freeSlotUsageMap and returning.');
    freeSlotUsageMap = {};
    return;
  }

  // Convert email to a Firebase-safe key
  const emailKey = currentPlayer.email.replace(/\./g, '_').toLowerCase();
  const dbRef = firebase.database().ref(`freeSlotUsage/${emailKey}`);

  // Build the updates object from freeSlotUsageMap
  const updates = {};
  for (let [weekKey, used] of Object.entries(freeSlotUsageMap)) {
    if (used) {
      updates[weekKey] = true;
    }
  }

  console.log('[recordFreeSlotUsage] Constructed updates =', JSON.stringify(updates, null, 2));

  // If there are no used weeks, nothing to store
  if (Object.keys(updates).length === 0) {
    console.log('[recordFreeSlotUsage] No used free slots detected => clearing and returning.');
    freeSlotUsageMap = {};
    return;
  }

  try {
    // Perform the multi-location update
    await dbRef.update(updates);
    console.log('[recordFreeSlotUsage] Successfully updated Firebase with =', updates);
  } catch (err) {
    console.error('[recordFreeSlotUsage] Error updating Firebase:', err);
  }

  // Finally, clear the ephemeral map
  freeSlotUsageMap = {};
  console.log('[recordFreeSlotUsage] Cleared freeSlotUsageMap. END.\n');
}




  async function submitCartToSpreadsheet(creditUsed) {
    const partnerNameValue = document.getElementById('partner-name').value;
    const playerMembership = currentPlayer.membershipType;
    const payload = {
      action: 'registerMultiple',
      firstName: currentPlayer.firstName,
      lastName: currentPlayer.lastName,
      email: currentPlayer.email,
      phoneNumber: currentPlayer.phoneNumber,
      cartItems: cartItems.map(ci => ({
        sessionId: ci.sessionId,
        program: ci.program
      })),
      creditUsed: creditUsed || 0,
      partnerName: partnerNameValue,
      cartItemsIo: cartItems.map(ci => ({
        sessionId: ci.sessionId,
        program: ci.program + (ci.indoorOutdoor ? ' | ' + ci.indoorOutdoor : '')
      })),
      membership: currentPlayer.membershipType
    };

    try {
      const resp = await fetch(GAS_PROXY, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const data = await resp.json();
      showMessage(`registerMultiple response: ${JSON.stringify(data)}`, 'debug');
      if (!data.success) {
        showMessage('Error registering: ' + (data.error || ''), 'error');
      } else {
        // Update local credit
        currentPlayer.credit = Math.max(0, (currentPlayer.credit || 0) - creditUsed);
        updateCreditDisplay();
      }
    } catch (err) {
      showMessage('submitCartToSpreadsheet error: ' + err.message, 'error');
    }
  }

/************************************************************
* 10) MY REGISTRATIONS
************************************************************/

// 1. Listen for the "My Registrations" tab to be shown, then load the data.
document.querySelector('a[data-bs-target="#tab-registrations"]')
.addEventListener('shown.bs.tab', loadUserRegistrations);

async function loadUserRegistrations() {
if (!currentPlayer || !currentPlayer.email) {
  showMessage('No user data found for registrations.', 'error');
  return;
}
showMessage('Loading user registrations from getUserRegistrations', 'debug');
showRegistrationsSpinner(true);

const url = `${GAS_PROXY}?action=getUserRegistrations&email=${encodeURIComponent(currentPlayer.email)}`;
try {
  const resp = await fetch(url);
  const data = await resp.json();
  showMessage(`getUserRegistrations response: ${JSON.stringify(data)}`, 'debug');

  if (!data.success) {
    showMessage('Error loading registrations: ' + (data.error || ''), 'error');
    return;
  }

  // Instead of renderFullCalendar, we call our new list-based rendering:
  renderRegistrationsList(data.upcoming || []);

} catch (err) {
  showMessage('Load registrations error: ' + err.message, 'error');
} finally {
  showRegistrationsSpinner(false);
}
}

/**
* Renders registrations as a date-grouped list, rather than a calendar.
* We still rely on parseProgramString() and its helpers for date/time parsing.
*/
// Helper function to generate a Google Calendar URL
// Helper function to generate a Google Calendar URL
function getGoogleCalendarUrl({ title, startDate, endDate, details = '', location = '' }) {
  const formatDate = date => date.toISOString().replace(/-|:|\.\d{3}/g, '');
  const start = formatDate(startDate);
  const end = formatDate(endDate);
  const baseUrl = 'https://www.google.com/calendar/render?action=TEMPLATE';
  const url = `${baseUrl}&text=${encodeURIComponent(title)}&dates=${start}/${end}&details=${encodeURIComponent(details)}&location=${encodeURIComponent(location)}`;
  return url;
}

// Helper function to generate an Outlook Calendar URL
function getOutlookCalendarUrl({ title, startDate, endDate, details = '', location = '' }) {
  // Dates in ISO format work well with Outlook
  const start = startDate.toISOString();
  const end = endDate.toISOString();
  const baseUrl = 'https://outlook.live.com/calendar/0/deeplink/compose';
  const url = `${baseUrl}?subject=${encodeURIComponent(title)}&body=${encodeURIComponent(details)}&startdt=${encodeURIComponent(start)}&enddt=${encodeURIComponent(end)}&location=${encodeURIComponent(location)}`;
  return url;
}

function renderRegistrationsList(sessionsArray) {
  const container = document.getElementById('registrations-content');
  container.innerHTML = '';

  // Collect all events from sessionsArray
  const events = [];
  sessionsArray.forEach(sessionObj => {
    sessionObj.programs.forEach(programStr => {
      const parsedList = parseProgramString(programStr, sessionObj);
      if (Array.isArray(parsedList)) {
        parsedList.forEach(ev => {
          const startDate = new Date(ev.start);
          const endDate   = new Date(ev.end);
          events.push({
            title: ev.title,
            startDate,
            endDate
          });
        });
      }
    });
  });

  // Define current date and the date six months from now
  const now = new Date();
  const sixMonthsFromNow = new Date();
  sixMonthsFromNow.setMonth(sixMonthsFromNow.getMonth() + 6);

  // Filter events to only include those within the next 6 months
  const filteredEvents = events.filter(ev => ev.startDate >= now && ev.startDate <= sixMonthsFromNow);

  if (!filteredEvents.length) {
    container.innerHTML = '<p>No upcoming registrations found.</p>';
    return;
  }

  // Sort filtered events by start date/time ascending
  filteredEvents.sort((a, b) => a.startDate - b.startDate);

  // Group events by local date (YYYY-MM-DD)
  const grouped = {};
  filteredEvents.forEach(ev => {
    const dateKey = `${ev.startDate.getFullYear()}-${(ev.startDate.getMonth() + 1)
      .toString().padStart(2, '0')}-${ev.startDate.getDate().toString().padStart(2, '0')}`;
    if (!grouped[dateKey]) grouped[dateKey] = [];
    grouped[dateKey].push(ev);
  });

  // Render each group with a date heading and list of events
  Object.keys(grouped).sort().forEach(dateKey => {
    const [year, month, day] = dateKey.split('-');
    const localDateObj = new Date(year, month - 1, day);
    const dateHeading = document.createElement('h5');
    dateHeading.className = 'py-2 px-3 text-white bg-primary mb-2 rounded';
    dateHeading.textContent = localDateObj.toLocaleDateString(undefined, {
      weekday: 'long', month: 'short', day: 'numeric'
    });
    container.appendChild(dateHeading);

    grouped[dateKey].forEach(ev => {
      const itemDiv = document.createElement('div');
      itemDiv.className = 'mb-2 p-2 border rounded';

      // Event title
      const titleEl = document.createElement('div');
      titleEl.textContent = ev.title;
      itemDiv.appendChild(titleEl);

      // Time range, e.g. "1:00 PM - 2:00 PM"
      const timeEl = document.createElement('div');
      timeEl.className = 'small text-muted';
      const startTimeStr = ev.startDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      const endTimeStr   = ev.endDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
      timeEl.textContent = `${startTimeStr} - ${endTimeStr}`;
      itemDiv.appendChild(timeEl);

      // Container for calendar links
      const linksContainer = document.createElement('div');
      linksContainer.className = 'mt-2';

      // Add "Add to Google Calendar" link
      const googleLink = document.createElement('a');
      googleLink.className = 'btn btn-xs btn-outline-primary me-2';
      googleLink.href = getGoogleCalendarUrl({
        title: ev.title,
        startDate: ev.startDate,
        endDate: ev.endDate,
        details: '',       // Optional: add event details here
        location: ''       // Optional: add event location here
      });
      googleLink.target = '_blank';
      googleLink.textContent = 'Add to Google Calendar';
      linksContainer.appendChild(googleLink);

      // Add "Add to Outlook Calendar" link
      const outlookLink = document.createElement('a');
      outlookLink.className = 'btn btn-xs btn-outline-secondary';
      outlookLink.href = getOutlookCalendarUrl({
        title: ev.title,
        startDate: ev.startDate,
        endDate: ev.endDate,
        details: '',       // Optional: add event details here
        location: ''       // Optional: add event location here
      });
      outlookLink.target = '_blank';
      outlookLink.textContent = 'Add to Outlook Calendar';
      linksContainer.appendChild(outlookLink);

      itemDiv.appendChild(linksContainer);
      container.appendChild(itemDiv);
    });
  });
}


/**
* parseProgramString(programStr, sessionObj)
* (Unchanged from your existing code, except we've removed references to FullCalendar.)
*/
function parseProgramString(programStr, sessionObj) {
const fallbackYear = new Date().getFullYear();

if (programStr.includes(';')) {
  // e.g. (12/2 - 1/6; 1:00pm - 2:00pm)
  const dayMatch = programStr.match(/\b(Monday|Mondays|Tuesday|Tuesdays|Wednesday|Wednesdays|Thursday|Thursdays|Friday|Fridays|Saturday|Saturdays|Sunday|Sundays)\b/i);
  let dayName = 'Monday';
  if (dayMatch) {
    dayName = dayMatch[1];
  }
  const dayOfWeek = mapDayNameToNumber(dayName);

  const parenMatch = programStr.match(/\(([^)]+)\)/);
  if (!parenMatch) return [];
  const inside = parenMatch[1].trim(); 
  const [datesPart, timesPart] = inside.split(';').map(s => s.trim());
  const [startDateStr, endDateStr] = datesPart.split('-').map(s => s.trim());
  const startDate = parseMMDD(startDateStr, fallbackYear);
  const endDate   = parseMMDD(endDateStr, fallbackYear);

  const [startTimeStr, endTimeStr] = timesPart.split('-').map(s => s.trim());
  const startTime = parseTime(startTimeStr);
  const endTime   = parseTime(endTimeStr);

  return createWeeklyEventsInRange({
    title: formatEventTitleWithCategory(programStr),
    dayOfWeek,
    startDate,
    endDate,
    startTime,
    endTime
  });

} else {
  // e.g. "Monday 1/6 | 1:00pm - 2:00pm (2.0 - 3.0)"
  const match = programStr.match(/(\d{1,2}\/\d{1,2})\s*\|\s*([\d:apm\s]+-\s*[\d:apm\s]+)/);
  if (!match) return [];
  const dateStr   = match[1];
  const timesStr  = match[2];
  const singleDate = parseMMDD(dateStr, fallbackYear);
  const [startTimeStr, endTimeStr] = timesStr.split('-').map(s => s.trim());
  const startTime = parseTime(startTimeStr);
  const endTime   = parseTime(endTimeStr);

  const startDateTime = combineDateTime(singleDate, startTime);
  const endDateTime   = combineDateTime(singleDate, endTime);

  return [{
    title: formatEventTitleWithCategory(programStr),
    start: startDateTime.toISOString(),
    end: endDateTime.toISOString()
  }];
}
}



/**
* formatEventTitleWithCategory(rawString)
* (Same logic you had before to embed category/level in the event title.)
*/
function formatEventTitleWithCategory(rawString) {
const matchParen = rawString.match(/\s*\(([^)]+)\)$/);
if (!matchParen) {
  return rawString;
}
const locationName = matchParen[1].trim();  
const trimmedProgram = rawString.replace(/\s*\([^)]*\)$/, '');
const sessionObj = allSessions.find(s => {
  return s.location && s.location.includes(locationName);
});
if (!sessionObj) {
  return rawString;
}
const product = sessionObj.products.find(p => p.program === trimmedProgram);
if (!product) {
  return rawString;
}
const cat = product.category || 'Unknown Category';
const lvl = product.level || 'Unknown Level';
return `${cat} ${lvl} (${locationName})`;
}


function createWeeklyDatesInRange(dayOfWeek, startDate, endDate) {
const results = [];
const current = new Date(startDate);
while (current <= endDate) {
  if (current.getDay() === dayOfWeek) {
    results.push(new Date(current));
  }
  current.setDate(current.getDate() + 1);
}
return results;
}

function parseAllDates(programStr) {
const fallbackYear = new Date().getFullYear();

// 1) Check for multi-week pattern => look for a semicolon inside parentheses
//    e.g. "(2/24 - 3/31; 2:00pm - 4:00pm)"
if (programStr.includes(';')) {
  // Attempt to find a day name, like "Mondays" or "Tuesday"
  const dayMatch = programStr.match(
    /\b(Monday|Mondays|Tuesday|Tuesdays|Wednesday|Wednesdays|Thursday|Thursdays|Friday|Fridays|Saturday|Saturdays|Sunday|Sundays)\b/i
  );
  let dayName = 'Monday';
  if (dayMatch) {
    dayName = dayMatch[1];
  }
  const dayOfWeek = mapDayNameToNumber(dayName);

  // Extract the portion inside parentheses (e.g. "2/24 - 3/31; 2:00pm - 4:00pm")
  const parenMatch = programStr.match(/\(([^)]+)\)/);
  if (!parenMatch) {
    // If parsing fails, return today's date as fallback
    return [new Date()];
  }

  const inside = parenMatch[1].trim(); 
  // inside might be "2/24 - 3/31; 2:00pm - 4:00pm"
  const [datesPart, /* timesPart */] = inside.split(';').map(s => s.trim());
  const [startDateStr, endDateStr] = datesPart.split('-').map(s => s.trim());

  // Parse the start/end of the date range
  const startDate = parseMMDD(startDateStr, fallbackYear);
  const endDate   = parseMMDD(endDateStr, fallbackYear);

  // createWeeklyDatesInRange => e.g. returns an array [Date(2/24), Date(3/2), Date(3/9), ...]
  const weeklyDates = createWeeklyDatesInRange(dayOfWeek, startDate, endDate);
  return weeklyDates;

} else {
  // 2) Single-date pattern => e.g. "Monday 2/24 | 2:00pm - 4:00pm"
  //    We'll look for the mm/dd => (\d{1,2}/\d{1,2})
  const match = programStr.match(/(\d{1,2}\/\d{1,2})\s*\|\s*([\d:apm\s]+-\s*[\d:apm\s]+)/);
  if (!match) {
    // Fallback to a single "today" date if we can't parse
    return [new Date()];
  }

  const dateStr  = match[1];  // e.g. "2/24"
  // We could parse timesStr if needed, but for day-level discount logic, it's not strictly necessary.
  // const timesStr = match[2]; // e.g. "2:00pm - 4:00pm"

  // Convert "2/24" => Date(YYYY, 1, 24)
  const singleDate = parseMMDD(dateStr, fallbackYear);

  return [singleDate];
}
}


/**
* mapDayNameToNumber(dayName)
*/
function mapDayNameToNumber(dayName) {
const dn = dayName.toLowerCase();
if (dn.startsWith('sun')) return 0;
if (dn.startsWith('mon')) return 1;
if (dn.startsWith('tue')) return 2;
if (dn.startsWith('wed')) return 3;
if (dn.startsWith('thu')) return 4;
if (dn.startsWith('fri')) return 5;
if (dn.startsWith('sat')) return 6;
return 1;
}

/**
* createWeeklyEventsInRange({ title, dayOfWeek, startDate, endDate, startTime, endTime })
*/
function createWeeklyEventsInRange({ title, dayOfWeek, startDate, endDate, startTime, endTime }) {
const events = [];
const current = new Date(startDate);
while (current <= endDate) {
  if (current.getDay() === dayOfWeek) {
    const startDateTime = combineDateTime(current, startTime);
    const endDateTime   = combineDateTime(current, endTime);
    events.push({
      title,
      start: startDateTime.toISOString(),
      end:   endDateTime.toISOString()
    });
  }
  current.setDate(current.getDate() + 1);
}
return events;
}

/**
* parseMMDD(mmdd, year)
*/
function parseMMDD(mmdd, year) {
const [m, d] = mmdd.split('/').map(Number);
return new Date(year, m - 1, d);
}

/**
* parseTime(timestr)
*/
function parseTime(timestr) {
timestr = timestr.toLowerCase().replace(/\s+/g, '');
const ampm = timestr.endsWith('am') ? 'am' : 'pm';
timestr = timestr.replace(/am|pm/, '');

const [hh, mm] = timestr.split(':').map(Number);
let hour = hh;
let minute = mm || 0;

if (ampm === 'pm' && hour < 12) hour += 12;
if (ampm === 'am' && hour === 12) hour = 0;

return { hour, minute };
}

/**
* combineDateTime(dateObj, timeObj)
*/
function combineDateTime(dateObj, timeObj) {
return new Date(
  dateObj.getFullYear(),
  dateObj.getMonth(),
  dateObj.getDate(),
  timeObj.hour,
  timeObj.minute,
  0
);
}


  /************************************************************
   * 11) PROFILE & LOGOUT
   ************************************************************/
  function setProfileData(player) {
    document.getElementById('profile-first-name').textContent = player.firstName || '';
    document.getElementById('profile-last-name').textContent = player.lastName || '';
    document.getElementById('profile-phone').textContent = player.phoneNumber || '';
    document.getElementById('profile-email').textContent = player.email || '';

    const fullName = `${player.firstName} ${player.lastName}`.trim();
    localStorage.setItem('playerFullName', fullName);

    const cardSpan   = document.getElementById('profile-card-last4');
    const cardButton = document.getElementById('profile-card-button');

    if (player.cardLast4) {
      cardSpan.textContent = `**** **** **** ${player.cardLast4}`;
      cardButton.style.display = 'inline-block';
      cardButton.textContent   = 'Update Card';
      cardButton.onclick = () => {
        window.open('https://billing.stripe.com/p/login/9AQ9Dc83k8pg6QM7ss', '_blank');
      };
    } else {
      cardSpan.textContent = 'No card on file';
      cardButton.style.display = 'inline-block';
      cardButton.textContent   = 'Add Card';
      cardButton.onclick = () => {
        const modalEl = new bootstrap.Modal(document.getElementById('paymentModal'));
        modalEl.show();
      };
    }

    const saveCardContainer = document.getElementById('save-card-checkbox-container');
      if (saveCardContainer) {
          if (player.cardLast4) {
          // user ALREADY has a card => hide the checkbox
          saveCardContainer.style.display = 'none';
          } else {
          // user has NO card => show the checkbox
          saveCardContainer.style.display = 'block';
          }
      }
    updateProfileBenefits();
    updateCreditDisplay();
  }

  function updateCreditDisplay() {
    const creditSpan = document.getElementById('profile-credit-amount');
    if (!creditSpan) return;
    const creditVal = currentPlayer?.credit || 0;
    if (creditVal > 0) {
      creditSpan.innerHTML = `$${creditVal.toFixed(2)}<br><small><i>Automatically applied at checkout</i></small>`;
    } else {
      creditSpan.textContent = 'No credit available';
    }
  }

  document.getElementById('logout-button').addEventListener('click', async () => {
    try {
      await auth.signOut();
      // onAuthStateChanged will handle the UI updates
    } catch (err) {
      showMessage('Error signing out: ' + err.message, 'error');
    }
  });

  function updateProfileBenefits() {
  // Retrieve the current player's membership type (e.g., "Silver", "Gold", "TripleCrown")
  const membership = currentPlayer.membershipType;
  if (!membership) return;
  const profileDiv = document.getElementById("profileBenefits");
  if (!profileDiv) return; // Exit if the target div doesn't exist

  // Start with a header indicating the membership benefits
  let html = `<h5>Your ${membership} Membership Benefits</h5>`;
  html += '<ul>';

  // For Gold members, insert the special first bullet
  if (membership === "Gold") {
    html += '<li>1 Free Program/Week (Clinic, Guided Drilling, or Guided Open Play)</li>';
  }

  // Iterate over each service in the discountMap to build benefit details
  for (const service in discountMap) {
    if (discountMap.hasOwnProperty(service)) {
      const serviceInfo = discountMap[service];
      const discount = serviceInfo[membership];

      // If discount is 1.0, display "Free" instead of "100% discount"
      const discountText = discount === 1.0 ? "Free" : `${discount * 100}% discount`;

      // Build the benefit text and append free eligibility if applicable
      let benefitText = `${service}: ${discountText}`;

      html += `<li>${benefitText}</li>`;
    }
  }

  if (membership === "TripleCrown") {
      html += `<li>Court Rentals: Free</li>`;
    } else {
      html += `<li>Court Rentals: 20% discount</li>`;
    }

  html += `<li>Access to member only events</li>`;
  html += `<li>Access to early signups</li>`;

  html += '</ul>';

  // Update the div's content with the newly generated HTML
  profileDiv.innerHTML = html;
}



  /************************************************************
   * 12) UTILITY: showMessage
   ************************************************************/
  function showMessage(msg, type = 'info') {
    console.log(`[${type.toUpperCase()}] ${msg}`);
    // Optionally display a toast or alert in the UI
  }

  /************************************************************
   * TOGGLE CALENDAR VIEW & 7-DAY LIST
   ************************************************************/
  function showToggleCalendarButton(shouldShow) {
    const toggleViewContainer = document.getElementById('toggle-view-container');
    if (!toggleViewContainer) return;
    toggleViewContainer.style.display = shouldShow ? 'block' : 'none';
  }

  document.getElementById('standardized-level-filter').addEventListener('change', () => {
selectedStandardizedLevel = document.getElementById('standardized-level-filter').value.trim();
// Refresh whichever view is relevant:
if (isListView) {
  renderProgramListForRange();
} else {
  renderProgramCards();
}
});

  // Toggle button => flips isListView, calls updateRegisterViewMode()
  document.getElementById('btn-toggle-calendar-view').addEventListener('click', () => {
    isListView = !isListView;
    updateRegisterViewMode();
    const programCardsContainer = document.getElementById('program-cards-container');
    const calendarBtn = document.getElementById('btn-toggle-calendar-view');
    if(calendarBtn.textContent.includes('Calendar')) {
      calendarBtn.textContent = "Switch to Program View";
      document.getElementById('category-filter-group').style.display = 'none';
      document.getElementById('program-cards-container').style.display = 'none';
      document.getElementById('category-filter').selectedIndex = 0;
    } else {
      calendarBtn.textContent = "Switch to Calendar View (Level Based)";
      document.getElementById('category-filter-group').style.display = 'block';
    }
    //document.getElementById('program-cards-container').style.display = 'block';
  });

  function populateStandardizedLevelDropdown() {
const sLevelSelect = document.getElementById('standardized-level-filter');
sLevelSelect.innerHTML = '<option value="">--Select Your Level--</option>';

const sLevelsSet = new Set();  
allProducts.forEach(prod => {
  (prod.standardizedLevelList || []).forEach(lvl => {
    sLevelsSet.add(lvl);
  });
});

const sLevelsArray = Array.from(sLevelsSet).sort();  // convert to array, optionally sort
sLevelsArray.forEach(sl => {
  const opt = document.createElement('option');
  opt.value = sl;
  opt.textContent = sl;
  sLevelSelect.appendChild(opt);
});

document.getElementById('standardized-level-filter-group').style.display = 'block';
}



  // Show/hide filters or list
  function updateRegisterViewMode() {
const filterSection         = document.getElementById('filter-section');
const programCardsContainer = document.getElementById('program-cards-container');
const listViewContainer     = document.getElementById('list-view-container');
const listContent           = document.getElementById('program-list-content');

// If we are switching *to* list view
if (isListView) {
  // 1) Hide all filter UI and program cards
  showFilterStep(0); // sets everything to display: none
  programCardsContainer.style.display = 'none';

  // 2) Show the 7-day list container
  listViewContainer.style.display = 'block';

  // 3) If a session is selected, render that 7-day list
  if (selectedSession) {
    renderProgramListForRange();
  } else {
    // If no session is selected yet, give a prompt
    listContent.innerHTML = '<p>Please select a session above.</p>';
  }

// Otherwise, we're switching *back* to the "filters/cards" view
} else {
  // 1) Hide the 7-day list
  listViewContainer.style.display = 'none';

  // 2) If a session is selected, show the correct filter step
  if (selectedSession) {
    // If user has *already* chosen day/time, we might go straight to step 4
    // Otherwise, we show step 1 (or 2/3 if partial filters are filled in).
    if (selectedDayTime) {
      showFilterStep(1); // Changed from 4 to 1 so that program cards aren't shown when switching back
    } else {
      showFilterStep(1); // or 2/3, depending on your filter logic
    }
  } else {
    // If no session is selected, just leave everything hidden (step 0)
    showFilterStep(0);
  }
}

// Finally, if we *remain* in list view, re-hide program cards in case
// something else called showFilterStep(4) behind the scenes:
if (isListView) {
  programCardsContainer.style.display = 'none';
}
}



  // Prepare earliest & latest date for the session
  function prepareListViewDates(sessionObj) {
    const validDates = [];
    const today = startOfDay(new Date());
    (sessionObj.products || []).forEach(prod => {
      if (!prod.program || prod.program.toLowerCase().includes('package')) return;
      const dt = parseProgramDate(prod.program);
      if (dt) validDates.push(dt);
    });
    if (!validDates.length) {
      minProgramDate = today;
      maxProgramDate = today;
      listViewStartDate = today;
      return;
    }
    validDates.sort((a, b) => a - b);
    minProgramDate = startOfDay(validDates[0]);
    maxProgramDate = startOfDay(validDates[validDates.length - 1]);
    listViewStartDate = (minProgramDate < today) ? today : minProgramDate;
  }

  function startOfDay(d) {
    return new Date(d.getFullYear(), d.getMonth(), d.getDate());
  }

  function parseProgramDate(programStr) {
    if (!programStr.includes('|')) return null;
    const leftSide = programStr.split('|')[0].trim();
    const parts = leftSide.split(' ');
    if (parts.length < 2) return null;
    const mmdd = parts[parts.length - 1];
    const [mm, dd] = mmdd.split('/').map(Number);
    if (!mm || !dd) return null;

    const now = new Date();
    let yyyy = now.getFullYear();
    const dateObj = new Date(yyyy, mm - 1, dd);

    // If it's more than ~6 months in the past, assume next year
    if (dateObj.getTime() < now.getTime() - 15778476000) {
      dateObj.setFullYear(yyyy + 1);
    }
    return startOfDay(dateObj);
  }

  function renderProgramListForRange() {
if (!selectedSession || !listViewStartDate) return;

// 1) If no standardized level => show message, remove any calendar
const calendarEl = document.getElementById('register-calendar');
if (!selectedStandardizedLevel) {
  if (registerCalendar) {
    registerCalendar.destroy();
    registerCalendar = null;
  }
  calendarEl.innerHTML = 
    `<div class="alert alert-info mb-2">
      Please select your level.
    </div>`
  ;
  return;
}

// Clear any old content
calendarEl.innerHTML = '';

// 2) Compute 7-day window
const rangeStart = startOfDay(listViewStartDate);
const rangeEnd = new Date(rangeStart);
rangeEnd.setDate(rangeStart.getDate() + 7);

// 3) Build an array of events
let events = [];
(selectedSession.products || []).forEach((prod) => {
  // skip "package" or blank
  if (!prod.program || prod.program.toLowerCase().includes('package')) return;

  // filter by standardized level
  const levelList = prod.standardizedLevelList || [];
  if (!levelList.includes(selectedStandardizedLevel)) return;

  // parse the product's program into date/time "events"
  const parsedEvents = parseProgramString(prod.program, selectedSession);
  if (!Array.isArray(parsedEvents)) return;

  parsedEvents.forEach((ev) => {
    const eventStartDate = new Date(ev.start);
    if (eventStartDate >= rangeStart && eventStartDate <= rangeEnd) {
      // Check if in cart
      const inCart = cartItems.some(
        (ci) =>
          ci.program === prod.program &&
          ci.sessionId === selectedSession.spreadsheetId
      );

      // Pick color based on category, soldOut, and inCart
      const { backgroundColor, borderColor } = getEventColors(prod, inCart);

      

    // === MEMBERSHIP PRICE LOGIC ===
    const cartItem = cartItems.find(
  ci => ci.program === prod.program && ci.sessionId === selectedSession.spreadsheetId
);
let memberPrice;
if (cartItem) {
  // Use the locked-in cart price (preserving the free item price if applicable)
  memberPrice = cartItem.price;
} else {
  // Use the read-only price calculation
  memberPrice = getDiscountedPrice(
    prod,
    currentPlayer?.membershipType,
    currentPlayer?.membershipEndDate,
    currentPlayer?.membershipStartDate,
    freeSlotUsageMap,
    { readOnly: true }
  ).total;
}
const basePrice = prod.price || 0;
let priceLabel = `$${memberPrice.toFixed(2)}`;

  if (memberPrice < basePrice) {
    const catMap = discountMap[prod.category] || {};
    const discountFactor = catMap[currentPlayer?.membershipType] || 0;
    const pct = Math.round(discountFactor * 100);
  }

  // Construct the event title
  let baseTitle = `${prod.category}: ${prod.level}`;
  if (prod.soldOut) {
    baseTitle += " (SOLD OUT)";
  }
  let displayedTitle = `${baseTitle} — ${priceLabel}`;
  if (inCart) {
    displayedTitle += " ✅ Added to Cart";
  }
  // === END MEMBERSHIP PRICE LOGIC ===

      events.push({
        title: displayedTitle,
        start: ev.start,
        end: ev.end,
        backgroundColor: backgroundColor,
        borderColor: borderColor,
        extendedProps: {
          product: prod,
          baseTitle: baseTitle
        }
      });
    }
  });
});

// 4) Create or update FullCalendar
if (!registerCalendar) {
  let defaultView = 'timeGridWeek';
      if (window.innerWidth < 768) {
      defaultView = 'listWeek';
      viewOptions = '';
      } else {
          defaultView = 'listWeek';
          viewOptions = 'listWeek,timeGridWeek';
      }

  registerCalendar = new FullCalendar.Calendar(calendarEl, {
    initialView: defaultView,
    dayHeaderFormat: { weekday: 'short' }, 
    slotMinTime: '05:00:00',
    slotMaxTime: '23:00:00',
    initialDate: rangeStart,
    events: events,
    contentHeight: 'auto',
    expandRows: true,
    headerToolbar: {
      left:'title',
    center: viewOptions,
    right: '',
    // => user sees two buttons on the right
  },
  buttonText: {
    listWeek: 'Weekly List View',
    timeGridWeek: 'Weekly Calendar View'
  },




  eventDidMount: function(info) {
  // Only add a tooltip in the timeGridWeek view
  if (info.view.type === 'timeGridWeek') {
    // Set the native title attribute
    info.el.setAttribute('title', info.event.title);
    // Initialize the Bootstrap tooltip on this element
    new bootstrap.Tooltip(info.el, {
      container: 'body'
    });
  }

  const product = info.event.extendedProps.product;
  if (!product) return;

  // If sold out => tint the row red in listWeek view and mark as sold-out
  if (product.soldOut) {
    info.el.style.backgroundColor = "#f8d7da";
    info.el.classList.add('sold-out');
    return; // no further styling
  }

  // If it's in cart and we're in listWeek, highlight row green
  const isInCart = cartItems.some(
    (ci) =>
      ci.program === product.program &&
      ci.sessionId === selectedSession.spreadsheetId
  );
  if (isInCart && info.view.type.startsWith('list')) {
    info.el.classList.add('selected-list-event');
  }

  // Append the link element in list views
  if (info.view.type.startsWith('list')) {
  const link = document.createElement('a');
  link.className = 'listPackageBtn';
  link.href = "#"; // Set the link destination as needed
  link.innerText = 'Discounted Packages & More Dates';

  link.addEventListener('click', (event) => {
    event.preventDefault();
    event.stopPropagation();

    // 1) Simulate a click on btn-toggle-calendar-view
    const toggleBtn = document.getElementById('btn-toggle-calendar-view');
    if (toggleBtn) {
      toggleBtn.click();
    }

    // 2) Run the autoPopulateFilters function with product values
    autoPopulateFilters(product.category, product.level, product.dayTime);
  });

  info.el.appendChild(link);
}
},



    // 5) eventClick => skip if sold out, else toggle cart and recalc color
    eventClick: function(info) {
        // Dispose of the tooltip if it exists
        const tooltip = bootstrap.Tooltip.getInstance(info.el);
        if (tooltip) {
          tooltip.dispose();
        }
      const product = info.event.extendedProps.product;
      if (!product) return;

      // If sold out => do nothing
      if (product.soldOut) {
        return;
      }

      // Check if in cart
      const isInCart = cartItems.some(
        (ci) =>
          ci.program === product.program &&
          ci.sessionId === selectedSession.spreadsheetId
      );

      if (isInCart) {
        // Remove from cart
        removeProductFromCart(product, selectedSession.spreadsheetId);

        // Now event is no longer in cart => pick the normal color
        const { backgroundColor, borderColor } = getEventColors(product, false);
        info.event.setProp("backgroundColor", backgroundColor);
        info.event.setProp("borderColor", borderColor);

      } else {
        // Add to cart
        addProductToCart(product);

        // Now event is in cart => use darker color
        const { backgroundColor, borderColor } = getEventColors(product, true);
        info.event.setProp("backgroundColor", backgroundColor);
        info.event.setProp("borderColor", borderColor);
      }
    }
  });
  registerCalendar.render();
} else {
  // Calendar exists => remove old events, jump to date, add events
  registerCalendar.removeAllEvents();
  registerCalendar.gotoDate(rangeStart);
  registerCalendar.addEventSource(events);
}
console.log("Found", events.length, "events for this range.");
console.log("Next 7 days invoked, new range =", listViewStartDate);
}



function getEventColors(prod, inCart) {
if (prod.soldOut) {
  // Soft red for sold-out
  return {
    backgroundColor: "#f8d7da",
    borderColor: "#f8d7da"
  };
}

// Not sold out => pick base or dark
const baseColor = CATEGORY_COLORS[prod.category] || "#0e2f7b";
const darkColor = CATEGORY_DARK_COLORS[prod.category] || "#2ECC40";
if (inCart) {
  return {
    backgroundColor: darkColor,
    borderColor: darkColor
  };
} else {
  return {
    backgroundColor: baseColor,
    borderColor: baseColor
  };
}
}

function getTimeGridColors(prod, inCart) {
// If sold out => soft red
if (prod.soldOut) {
  return { backgroundColor: "#f8d7da", borderColor: "#f8d7da" };
}
// Otherwise => base or dark
const base  = CATEGORY_COLORS[prod.category] || "#888888";
const dark  = CATEGORY_DARK_COLORS[prod.category] || "#666666";
if (inCart) {
  return { backgroundColor: dark, borderColor: dark };
} else {
  return { backgroundColor: base, borderColor: base };
}
}



// Helper functions to get the next or previous Sunday relative to a given date.
function getNextSunday(date) {
const d = new Date(date);
const day = d.getDay();
// If already Sunday, jump forward 7 days; otherwise, add enough days to reach Sunday.
const offset = day === 0 ? 7 : (7 - day);
d.setDate(d.getDate() + offset);
return d;
}

function getPreviousSunday(date) {
const d = new Date(date);
const day = d.getDay();
// If already Sunday, jump back 7 days; otherwise, subtract the day number to reach Sunday.
const offset = day === 0 ? 7 : day;
d.setDate(d.getDate() - offset);
return d;
}

document.getElementById('btn-list-prev').addEventListener('click', () => {
if (!listViewStartDate || !minProgramDate) return;

// Normalize "today" (set hours to zero so comparisons work correctly)
const today = new Date();
today.setHours(0, 0, 0, 0);

// Compute the previous Sunday based on the current listViewStartDate.
let computedPrevious = getPreviousSunday(listViewStartDate);
let newStart;

// If the current view is in the future (listViewStartDate > today) and the computed previous Sunday
// falls before today, then jump directly to today (even if today isn't a Sunday).
if (listViewStartDate > today && computedPrevious < today) {
  newStart = today;
} else {
  newStart = computedPrevious;
}

// Clamp to minProgramDate.
if (newStart < minProgramDate) {
  newStart = new Date(minProgramDate);
  // Only adjust to Sunday if the clamped date isn't already today.
  if (newStart.getDay() !== 0 && newStart.getTime() !== today.getTime()) {
    newStart = getNextSunday(newStart);
  }
}

listViewStartDate = newStart;
renderProgramListForRange(); // re-render calendar
});

document.getElementById('btn-list-next').addEventListener('click', () => {
if (!listViewStartDate || !maxProgramDate) return;

// Compute the next Sunday from the current listViewStartDate.
let newStart = getNextSunday(listViewStartDate);

// Clamp to maxProgramDate.
if (newStart > maxProgramDate) {
  newStart = new Date(maxProgramDate);
  if (newStart.getDay() !== 0) {
    newStart = getPreviousSunday(newStart);
  }
}

listViewStartDate = newStart;
renderProgramListForRange(); // re-render calendar
});


function updateMembershipMessage() {
  const msgEl = document.getElementById('membership-message');
  const extndMsg = document.getElementById('extndMsg');
  if (!msgEl) return; // If the element doesn't exist, just bail.

  // If the user has a membership type and an end date (and start date), show a message
  if (currentPlayer?.membershipType && currentPlayer?.membershipEndDate && currentPlayer?.membershipStartDate) {
    const startDate = new Date(currentPlayer.membershipStartDate);
    const endDate   = new Date(currentPlayer.membershipEndDate);
    const now       = new Date();

    // Format the dates for display, e.g. "Apr 1, 2025"
    const startDateStr = startDate.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
    const endDateStr = endDate.toLocaleDateString(undefined, {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });

    // If membership hasn't started yet => "will be applied between ..."
    // Otherwise => "applied through endDate"
    if (now < startDate) {
      msgEl.textContent = `Your ${currentPlayer.membershipType} membership benefits are automatically applied for programs between ${startDateStr} and ${endDateStr}.`;
    } else {
      msgEl.textContent = `Your ${currentPlayer.membershipType} membership benefits are automatically applied through ${endDateStr}.`;
    }

    // Show the message elements
    msgEl.style.display = 'block';
    if (extndMsg) {
      extndMsg.style.display = 'block';
    }
  } else {
    // Hide if no membership data
    msgEl.style.display = 'none';
    if (extndMsg) {
      extndMsg.style.display = 'none';
    }
  }
}

/**
 * fetchExistingFreeSlots
 * 
 * Reads from Firebase all prior free-slot usage for the given email.
 * Merges that data into freeSlotUsageMap so the user won't get a second free slot for that same Monday–Sunday.
 * 
 * Call this after you have `currentPlayer.email` but before the user picks new items.
 */
 async function fetchExistingFreeSlots(email) {
  if (!email) return;
  const emailKey = email.replace(/\./g, '_').toLowerCase();

  try {
    const snapshot = await firebase.database().ref(`freeSlotUsage/${emailKey}`).once('value');
    const data = snapshot.val() || {};
    // data looks like { "2025-03-17": true, "2025-03-24": true, ... }
    for (let [weekKey, used] of Object.entries(data)) {
      if (used) {
        freeSlotUsageMap[weekKey] = true;
      }
    }
  } catch (err) {
    console.error('Error fetching existing free slots:', err);
  }
}

/**
 * Fetches player info from Firebase using email
 */
async function getPlayerInfoFromFirebase(email) {
    // Convert email to Firebase-safe key format - replace both . and @ with _
    const emailKey = email.replace(/[.@]/g, '_').toLowerCase();
    
    try {
        // Reference the players node and get the specific player
        const snapshot = await firebase.database().ref(`players/${emailKey}`).once('value');
        const playerData = snapshot.val();
        
        if (!playerData) {
            return {
                success: false,
                error: 'Player not found'
            };
        }

        return {
            success: true,
            player: {
                firstName: playerData.firstName,
                lastName: playerData.lastName,
                email: playerData.email,
                phoneNumber: playerData.phone,
                credit: playerData.credit || 0  // Add credit from Firebase
            }
        };
    } catch (err) {
        console.error('Error fetching player from Firebase:', err);
        return {
            success: false,
            error: err.message
        };
    }
}

// Add near the top with other state variables
let isLoadingSessions = false;
let sessionsLoadError = null;

// Add new session management functions
async function initializeSessionData() {
  isLoadingSessions = true;
  sessionsLoadError = null;
  updateRegisterTabState();

  try {
    showMessage('Loading sessions from getSessions', 'debug');
    const url = `${GAS_PROXY}?action=getSessions`;
    const resp = await fetch(url);
    const data = await resp.json();

    if (!data.success) {
      throw new Error(data.error || 'Failed to load sessions');
    }

    const sessionInfos = data.sessions || [];
    const sessionPromises = sessionInfos.map(sess => fetchProgramsForSession(sess));
    allSessions = await Promise.all(sessionPromises);
    
    // Now display them as cards
    displaySessionCards(allSessions);
    isLoadingSessions = false;
    sessionsLoadError = null;
  } catch (err) {
    showMessage('Session load error: ' + err.message, 'error');
    isLoadingSessions = false;
    sessionsLoadError = err.message;
  }
  
  updateRegisterTabState();
}

function updateRegisterTabState() {
  const registerTab = document.querySelector('[data-bs-target="#tab-register"]');
  const registerSpinner = document.getElementById('register-tab-spinner');
  const registerError = document.getElementById('register-tab-error');
  const sessionCards = document.getElementById('session-cards');

  if (isLoadingSessions) {
    registerTab.classList.add('loading');
    registerSpinner.style.display = 'block';
    registerError.style.display = 'none';
    if (sessionCards) sessionCards.style.opacity = '0.5';
  } else if (sessionsLoadError) {
    registerTab.classList.remove('loading');
    registerSpinner.style.display = 'none';
    registerError.style.display = 'block';
    if (sessionCards) sessionCards.style.opacity = '1';
  } else {
    registerTab.classList.remove('loading');
    registerSpinner.style.display = 'none';
    registerError.style.display = 'none';
    if (sessionCards) sessionCards.style.opacity = '1';
  }
}

async function retryLoadSessions() {
  await initializeSessionData();
}

// Modify initiateValidationFlow to separate session loading
async function initiateValidationFlow(email) {
    document.getElementById('mainNav').classList.remove('d-none');
    showMessage(`initiateValidationFlow for email: ${email}`, 'debug');
    showProfileSpinner(true);

try {
  // 1) Get player info from Firebase instead of GAS
  const playerData = await getPlayerInfoFromFirebase(email);
  showMessage(`playerData: ${JSON.stringify(playerData)}`, 'debug');

  if (!playerData.success || !playerData.player) {
    const welcomeModal = new bootstrap.Modal(document.getElementById('welcomeModal'));
    welcomeModal.show();
    showMessage(`Error retrieving or invalid player: ${playerData.error}`, 'error');
    showProfileSpinner(false);
    return;
  }
  currentPlayer = playerData.player;

  // 2) Check Stripe
  const stripeUrl = `${FIND_STRIPE_URL}?email=${encodeURIComponent(email)}`;
  const stripeResp = await fetch(stripeUrl);
  const stripeData = await stripeResp.json();
  showMessage(`stripeData: ${JSON.stringify(stripeData)}`, 'debug');

  if (!stripeData.success) {
    showMessage('Error checking Stripe: ' + (stripeData.error || ''), 'error');
    showProfileSpinner(false);
  }
  if (stripeData.exists) {
    currentPlayer.cardLast4 = stripeData.cardLast4 || null;
  } else {
    showMessage('No Stripe customer found => Payment Profile needed', 'debug');
  }

  // Remove credit fetch since it's now included in player data
  showMessage(`Credit from Firebase: ${currentPlayer.credit}`, 'debug');

  // 4) Fetch membership from Firebase Realtime Database
  try {
    const dbRef = firebase.database().ref('subscriptions');
    // We'll read ALL subscriptions and find the one that matches currentPlayer.email
    const snapshot = await dbRef.once('value');
    const subsData = snapshot.val() || {};
    let membershipType = null;
    let membershipEnd = null;

    Object.keys(subsData).forEach(key => {
      const sub = subsData[key];
      if (sub && sub.email && sub.email.toLowerCase() === currentPlayer.email.toLowerCase()) {
        if (sub.active) {
          membershipType = sub.membershipType || null;
          membershipEnd  = sub.endDate || null;
          membershipStart = sub.startDate || null;
        }
      }
    });
    
    currentPlayer.membershipType = membershipType;
    currentPlayer.membershipEndDate = membershipEnd;
    currentPlayer.membershipStartDate = membershipStart;

    if (currentPlayer.membershipType) {
      const now = new Date();
      const endDate = new Date(membershipEnd);
      if (endDate > now) {
        document.getElementById('home-link-forum').style.display = 'block';
      }
    }

    showMessage(`Membership found: type=${membershipType}, end=${membershipEnd}`, 'debug');
  } catch (firebaseErr) {
    showMessage('Error fetching membership from Firebase: ' + firebaseErr.message, 'error');
    currentPlayer.membershipType = null;
    currentPlayer.membershipEndDate = null;
    currentPlayer.membershipStartDate = null;
  }

  await fetchExistingFreeSlots(currentPlayer.email);

  // Show profile and enable webapp
  setProfileData(currentPlayer);
  updateMembershipMessage();
  showProfileSpinner(false);
  uploadUserEmail();

  // Start loading sessions in background
  initializeSessionData();

  if (!stripeData.exists && !document.referrer && !document.referrer.includes('subscription.html')) {
    const modalEl = new bootstrap.Modal(document.getElementById('paymentModal'));
    modalEl.show();
  }
  if (currentPlayer.firstName) {
    document.getElementById('welcomeMsg').textContent = `Hey ${currentPlayer.firstName}! Welcome to our Montclair Pickelball Player Portal.`;
  }
  
} catch (err) {
  showMessage('initiateValidationFlow error: ' + err.message, 'error');
  showProfileSpinner(false);
}
}

// Add tab change listener to handle loading states
document.querySelectorAll('a[data-bs-toggle="tab"]').forEach(tab => {
  tab.addEventListener('shown.bs.tab', function (e) {
    currentActiveTab = e.target.getAttribute('data-bs-target');
    if (currentActiveTab === '#tab-register') {
      updateRegisterTabState();
    }
  });
});

// Update the email verification login option handler
document.getElementById('btn-email-verify').addEventListener('click', async () => {
  const email = document.getElementById('login-email').value.trim();
  
  // Show verification screen immediately with loading state
  document.getElementById('login-options').style.display = 'none';
  document.getElementById('code-entry').style.display = 'block';
  document.getElementById('code-entry-loading').style.display = 'block';
  document.getElementById('code-entry-form').style.display = 'none';
  
  try {
    const url = `${GAS_PROXY}?action=sendVerificationEmail&email=${encodeURIComponent(email)}`;
    const resp = await fetch(url);
    const data = await resp.json();
    
    if (data.success) {
      window.__verificationCode = data.code;
      // Hide loading, show form
      document.getElementById('code-entry-loading').style.display = 'none';
      document.getElementById('code-entry-form').style.display = 'block';
    } else {
      alert('Error sending code: ' + (data.error || 'Unknown'));
      // Go back to login options on error
      document.getElementById('code-entry').style.display = 'none';
      document.getElementById('login-options').style.display = 'block';
    }
  } catch (err) {
    alert('Network error: ' + err.message);
    // Go back to login options on error
    document.getElementById('code-entry').style.display = 'none';
    document.getElementById('login-options').style.display = 'block';
  }
});

// Handle password login
document.getElementById('btn-password-login').addEventListener('click', () => {
  document.getElementById('login-options').style.display = 'none';
  document.getElementById('password-login-form').style.display = 'block';
});

document.getElementById('password-login-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const email = document.getElementById('login-email').value.trim();
  const password = document.getElementById('login-password').value;
  const errorDiv = document.getElementById('login-error');
  
  try {
    await auth.signInWithEmailAndPassword(email, password);
    // onAuthStateChanged will handle the rest
  } catch (err) {
    if (err.code === 'auth/invalid-login-credentials' || 
        err.code === 'auth/wrong-password' || 
        err.code === 'auth/user-not-found') {
      errorDiv.innerHTML = `Invalid password. If you haven't created a password for your account yet, <a href="#" class="alert-link" id="error-create-password">click here to create one</a>.`;
      document.getElementById('error-create-password').addEventListener('click', (e) => {
        e.preventDefault();
        document.getElementById('btn-create-password').click();
      });
    } else {
      errorDiv.textContent = err.message;
    }
    errorDiv.style.display = 'block';
  }
});

// Handle create password account
document.getElementById('btn-create-password').addEventListener('click', () => {
  document.getElementById('password-login-form').style.display = 'none';
  document.getElementById('create-password-form').style.display = 'block';
  // Email field should be readonly and pre-filled
  document.getElementById('create-email').value = document.getElementById('login-email').value;
});

document.getElementById('create-password-form').addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const email = document.getElementById('create-email').value.trim();
  const password = document.getElementById('create-password').value;
  const confirmPassword = document.getElementById('confirm-password').value;
  const errorDiv = document.getElementById('create-error');
  
  if (password !== confirmPassword) {
    errorDiv.textContent = 'Passwords do not match';
    errorDiv.style.display = 'block';
    return;
  }
  
  try {
    await auth.createUserWithEmailAndPassword(email, password);
    // onAuthStateChanged will handle the rest
  } catch (err) {
    errorDiv.textContent = err.message;
    errorDiv.style.display = 'block';
  }
});

// Handle forgot password
document.getElementById('btn-forgot-password').addEventListener('click', async () => {
  const email = document.getElementById('login-email').value.trim();
  const forgotBtn = document.getElementById('btn-forgot-password');
  const successDiv = document.getElementById('password-reset-success');
  const errorDiv = document.getElementById('login-error');
  
  if (!email) {
    errorDiv.textContent = 'Please enter your email address';
    errorDiv.style.display = 'block';
    successDiv.style.display = 'none';
    return;
  }
  
  try {
    forgotBtn.disabled = true;
    forgotBtn.textContent = 'Sending reset email...';
    
    await auth.sendPasswordResetEmail(email);
    
    // Show success message
    successDiv.style.display = 'block';
    errorDiv.style.display = 'none';
    forgotBtn.textContent = 'Reset email sent!';
  } catch (err) {
    // Show error message
    errorDiv.textContent = 'Error sending reset email: ' + err.message;
    errorDiv.style.display = 'block';
    successDiv.style.display = 'none';
    forgotBtn.textContent = 'Forgot Password?';
    forgotBtn.disabled = false;
  }
});

// Handle back buttons
document.getElementById('btn-back-to-options').addEventListener('click', () => {
  document.getElementById('password-login-form').style.display = 'none';
  document.getElementById('login-options').style.display = 'block';
});

document.getElementById('btn-back-from-create').addEventListener('click', () => {
  document.getElementById('create-password-form').style.display = 'none';
  document.getElementById('login-options').style.display = 'block';
});

document.getElementById('btn-back-to-email').addEventListener('click', () => {
  document.getElementById('new-user-prompt').style.display = 'none';
  document.getElementById('verification-form').style.display = 'block';
  document.getElementById('verify-email-input').value = '';
  // Restore the welcome heading and paragraph
  const welcomeHeading = document.querySelector('#verification-section h5');
  const welcomeParagraph = document.querySelector('#verification-section > p');
  if (welcomeHeading) welcomeHeading.style.display = '';
  if (welcomeParagraph) welcomeParagraph.style.display = '';
});

// Update the back button on create password form
document.getElementById('btn-back-to-login').addEventListener('click', () => {
  document.getElementById('create-password-form').style.display = 'none';
  document.getElementById('password-login-form').style.display = 'block';
});

  /************************************************************
   * NEW PROGRAM GROUPING AND FILTERING FUNCTIONS
   ************************************************************/
  function parseFirstDateFromProgram(programStr) {
    const fallbackYear = new Date().getFullYear();
    
    if (programStr.includes(';')) {
      // Format: "(12/2 - 1/6; 1:00pm - 2:00pm)"
      const match = programStr.match(/\((\d{1,2}\/\d{1,2})/);
      if (match) {
        const [month, day] = match[1].split('/').map(Number);
        return new Date(fallbackYear, month - 1, day);
      }
    } else {
      // Format: "Monday 1/6 | 1:00pm - 2:00pm"
      const match = programStr.match(/(\d{1,2}\/\d{1,2})\s*\|/);
      if (match) {
        const [month, day] = match[1].split('/').map(Number);
        return new Date(fallbackYear, month - 1, day);
      }
    }
    return null;
  }

  function groupProgramsByDate(products) {
    const groups = {};
    
    products.forEach(product => {
      const date = parseFirstDateFromProgram(product.program);
      if (date) {
        const dateKey = date.toISOString().split('T')[0];
        if (!groups[dateKey]) {
          groups[dateKey] = {
            date: date,
            products: []
          };
        }
        groups[dateKey].products.push(product);
      }
    });
    
    // Sort dates
    return Object.entries(groups)
      .sort(([,a], [,b]) => a.date - b.date)
      .map(([key, value]) => value);
  }

  function createFilterCheckboxes() {
    // Create standardized level filters
    const levelSet = new Set();
    allProducts.forEach(prod => {
      (prod.standardizedLevelList || []).forEach(level => levelSet.add(level));
    });
    
    // Create category filters
    const categorySet = new Set();
    allProducts.forEach(prod => {
      if (prod.category) categorySet.add(prod.category);
    });
    
    const filterSection = document.getElementById('filter-section');
    
    // Check if we're on mobile - only check once at creation time
    const isMobile = window.innerWidth < 768;
    const defaultCollapseState = isMobile ? '' : 'show';
    
    // Create a new container structure for the desktop layout
    const container = document.createElement('div');
    container.className = 'container-fluid px-0';
    container.innerHTML = `
      <div class="row">
        <!-- Filters Column (Left Side) -->
        <div class="col-12 col-md-3 mb-3">
          <div class="card">
            <div class="card-body p-3">
              <!-- Clear Filters and Packages Buttons -->
              <div class="d-grid gap-2 mb-3">
                <button class="btn btn-outline-secondary w-100" type="button" id="clear-filters-btn">
                  <i class="bi bi-x-circle"></i> Clear All Filters
                </button>
                <button class="btn btn-outline-warning w-100" type="button" id="packages-toggle-btn">
                  <i class="bi bi-box"></i> Discounted Packages
                </button>
              </div>

              <!-- Level Filter Section -->
              <div class="mb-3">
                <button class="btn btn-outline-primary w-100 mb-2" type="button" data-bs-toggle="collapse" data-bs-target="#levelFiltersCollapse" aria-expanded="${!isMobile}">
                  <i class="bi bi-funnel"></i> Filter by Level
                  <span class="arrow float-end" style="transform: ${isMobile ? 'rotate(0deg)' : 'rotate(180deg)'}">&#9660;</span>
                </button>
                
                <div class="collapse ${defaultCollapseState}" id="levelFiltersCollapse">
                  <div id="level-filters" class="d-flex flex-column gap-2">
                    ${Array.from(levelSet).map(level => `
                      <div class="form-check">
                        <input class="form-check-input level-filter" type="checkbox" value="${level}" id="level-${level}">
                        <label class="form-check-label" for="level-${level}">${level}</label>
                      </div>
                    `).join('')}
                  </div>
                </div>
              </div>

              <!-- Category Filter Section -->
              <div class="mb-3">
                <button class="btn btn-outline-primary w-100 mb-2" type="button" data-bs-toggle="collapse" data-bs-target="#categoryFiltersCollapse" aria-expanded="${!isMobile}">
                  <i class="bi bi-funnel"></i> Filter by Category
                  <span class="arrow float-end" style="transform: ${isMobile ? 'rotate(0deg)' : 'rotate(180deg)'}">&#9660;</span>
                </button>
                
                <div class="collapse ${defaultCollapseState}" id="categoryFiltersCollapse">
                  <div id="category-filters" class="d-flex flex-column gap-2">
                    ${Array.from(categorySet).map(category => `
                      <div class="form-check">
                        <input class="form-check-input category-filter" type="checkbox" value="${category}" id="cat-${category}">
                        <label class="form-check-label" for="cat-${category}">${category}</label>
                      </div>
                    `).join('')}
                  </div>
                </div>
              </div>

              <!-- Date Filter Section -->
              <div class="mb-3">
                <button class="btn btn-outline-primary w-100 mb-2" type="button" data-bs-toggle="collapse" data-bs-target="#dateFiltersCollapse" aria-expanded="${!isMobile}">
                  <i class="bi bi-calendar"></i> Filter by Date
                  <span class="arrow float-end" style="transform: ${isMobile ? 'rotate(0deg)' : 'rotate(180deg)'}">&#9660;</span>
                </button>
                
                <div class="collapse ${defaultCollapseState}" id="dateFiltersCollapse">
                  <div id="date-filters" class="d-flex flex-column gap-2">
                    <div class="form-check">
                      <input class="form-check-input date-filter" type="radio" name="dateFilter" value="today" id="date-today">
                      <label class="form-check-label" for="date-today">Today</label>
                    </div>
                    <div class="form-check">
                      <input class="form-check-input date-filter" type="radio" name="dateFilter" value="tomorrow" id="date-tomorrow">
                      <label class="form-check-label" for="date-tomorrow">Tomorrow</label>
                    </div>
                    <div class="form-check">
                      <input class="form-check-input date-filter" type="radio" name="dateFilter" value="thisWeek" id="date-thisWeek">
                      <label class="form-check-label" for="date-thisWeek">This Week</label>
                    </div>
                    <div class="form-check">
                      <input class="form-check-input date-filter" type="radio" name="dateFilter" value="nextWeek" id="date-nextWeek">
                      <label class="form-check-label" for="date-nextWeek">Next Week</label>
                    </div>
                    <div class="form-check">
                      <input class="form-check-input date-filter" type="radio" name="dateFilter" value="dateRange" id="date-range">
                      <label class="form-check-label" for="date-range">Date Range</label>
                    </div>
                    <div id="date-range-inputs" class="mt-2" style="display: none;">
                      <div class="mb-2">
                        <label class="form-label small">Start Date:</label>
                        <input type="date" id="date-range-start" class="form-control form-control-sm">
                      </div>
                      <div>
                        <label class="form-label small">End Date:</label>
                        <input type="date" id="date-range-end" class="form-control form-control-sm">
                      </div>
                    </div>
                  </div>
                </div>
              </div>

            </div>
          </div>
        </div>

        <!-- Programs Column (Right Side) -->
        <div class="col-12 col-md-9">
          <div id="program-cards-container"></div>
        </div>
      </div>
    `;

    // Clear and replace the filter section content
    filterSection.innerHTML = '';
    filterSection.appendChild(container);
    
    // Add event listeners for filters
    document.querySelectorAll('.level-filter, .category-filter').forEach(checkbox => {
      checkbox.addEventListener('change', renderFilteredPrograms);
    });

    // Add event listener for packages toggle
    const packagesBtn = document.getElementById('packages-toggle-btn');
    packagesBtn.addEventListener('click', () => {
      showOnlyPackages = !showOnlyPackages;
      packagesBtn.classList.toggle('btn-warning');
      packagesBtn.classList.toggle('btn-outline-warning');
      renderFilteredPrograms();
    });

    // Add event listener for date filters
    document.querySelectorAll('.date-filter').forEach(radio => {
      radio.addEventListener('change', (e) => {
        // Show/hide date range inputs
        const dateRangeInputs = document.getElementById('date-range-inputs');
        dateRangeInputs.style.display = e.target.value === 'dateRange' ? 'block' : 'none';
        
        // Clear date range inputs when switching away from date range
        if (e.target.value !== 'dateRange') {
          document.getElementById('date-range-start').value = '';
          document.getElementById('date-range-end').value = '';
        }
        
        renderFilteredPrograms();
      });
    });

    // Add event listeners for date range inputs
    document.getElementById('date-range-start').addEventListener('change', renderFilteredPrograms);
    document.getElementById('date-range-end').addEventListener('change', renderFilteredPrograms);

    // Add event listener for Clear Filters button
    document.getElementById('clear-filters-btn').addEventListener('click', () => {
      // Clear date filters
      document.querySelectorAll('.date-filter').forEach(radio => {
        radio.checked = false;
      });
      
      // Clear date range inputs
      document.getElementById('date-range-inputs').style.display = 'none';
      document.getElementById('date-range-start').value = '';
      document.getElementById('date-range-end').value = '';
      
      // Clear level filters
      document.querySelectorAll('.level-filter').forEach(checkbox => {
        checkbox.checked = false;
      });
      
      // Clear category filters
      document.querySelectorAll('.category-filter').forEach(checkbox => {
        checkbox.checked = false;
      });

      // Reset packages toggle
      showOnlyPackages = false;
      const packagesBtn = document.getElementById('packages-toggle-btn');
      packagesBtn.classList.remove('btn-warning');
      packagesBtn.classList.add('btn-outline-warning');
      
      // Reset display limit
      resetDisplayLimit();
      
      // Re-render programs
      renderFilteredPrograms();
    });

    // Add event listeners for collapse arrows
    document.querySelectorAll('[data-bs-toggle="collapse"]').forEach(button => {
      button.addEventListener('click', function() {
        const arrow = this.querySelector('.arrow');
        if (this.getAttribute('aria-expanded') === 'true') {
          arrow.style.transform = 'rotate(180deg)';
        } else {
          arrow.style.transform = 'rotate(0deg)';
        }
      });
    });

    // Set min date for date pickers to today
    const today = new Date().toISOString().split('T')[0];
    const dateRangeStart = document.getElementById('date-range-start');
    const dateRangeEnd = document.getElementById('date-range-end');
    dateRangeStart.min = today;
    dateRangeEnd.min = today;

    // When start date changes, update end date min
    dateRangeStart.addEventListener('change', function() {
      dateRangeEnd.min = this.value;
      if (dateRangeEnd.value && dateRangeEnd.value < this.value) {
        dateRangeEnd.value = this.value;
      }
    });
}

  function getSelectedFilters() {
    const selectedLevels = Array.from(document.querySelectorAll('.level-filter:checked'))
      .map(cb => cb.value);
    const selectedCategories = Array.from(document.querySelectorAll('.category-filter:checked'))
      .map(cb => cb.value);
    const selectedDate = document.querySelector('.date-filter:checked')?.value;
    return { selectedLevels, selectedCategories, selectedDate };
}

function getDateRange(dateFilter) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    // Get the start of this week (Sunday)
    const thisWeekStart = new Date(today);
    thisWeekStart.setDate(today.getDate() - today.getDay());
    thisWeekStart.setHours(0, 0, 0, 0);
    
    // Get the end of this week (Saturday)
    const thisWeekEnd = new Date(thisWeekStart);
    thisWeekEnd.setDate(thisWeekStart.getDate() + 6);
    thisWeekEnd.setHours(23, 59, 59, 999);
    
    // Get the start of next week (next Sunday)
    const nextWeekStart = new Date(thisWeekEnd);
    nextWeekStart.setDate(thisWeekEnd.getDate() + 1);
    nextWeekStart.setHours(0, 0, 0, 0);
    
    // Get the end of next week (next Saturday)
    const nextWeekEnd = new Date(nextWeekStart);
    nextWeekEnd.setDate(nextWeekStart.getDate() + 6);
    nextWeekEnd.setHours(23, 59, 59, 999);
    
    switch (dateFilter) {
        case 'today': {
            const endOfToday = new Date(today);
            endOfToday.setHours(23, 59, 59, 999);
            return { start: today, end: endOfToday };
        }
        case 'tomorrow': {
            const endOfTomorrow = new Date(tomorrow);
            endOfTomorrow.setHours(23, 59, 59, 999);
            return { start: tomorrow, end: endOfTomorrow };
        }
        case 'thisWeek':
            return { start: thisWeekStart, end: thisWeekEnd };
        case 'nextWeek':
            return { start: nextWeekStart, end: nextWeekEnd };
        case 'dateRange': {
            const startInput = document.getElementById('date-range-start');
            const endInput = document.getElementById('date-range-end');
            
            if (!startInput.value) return null;
            
            // Create date at start of day (00:00:00)
            const start = new Date(startInput.value + 'T00:00:00');
            
            let end;
            if (endInput.value) {
                // Create date at end of day (23:59:59.999)
                end = new Date(endInput.value + 'T23:59:59.999');
            } else {
                // If no end date, use start date as end date (end of day)
                end = new Date(start);
                end.setHours(23, 59, 59, 999);
            }
            
            return { start, end };
        }
        default:
            return null;
    }
}

function renderFilteredPrograms() {
    const { selectedLevels, selectedCategories, selectedDate } = getSelectedFilters();
    
    // Filter products
    let filtered = allProducts;

    // Apply packages filter first if enabled
    if (showOnlyPackages) {
        filtered = filtered.filter(prod => prod.program.toLowerCase().includes('package'));
    }
    
    // Apply level filter
    if (selectedLevels.length > 0) {
        filtered = filtered.filter(prod => 
            prod.standardizedLevelList?.some(level => selectedLevels.includes(level))
        );
    }
    
    // Apply category filter
    if (selectedCategories.length > 0) {
        filtered = filtered.filter(prod => 
            selectedCategories.includes(prod.category)
        );
    }
    
    // Apply date filter
    if (selectedDate) {
        const dateRange = getDateRange(selectedDate);
        if (dateRange) {
            filtered = filtered.filter(prod => {
                const programDate = parseFirstDateFromProgram(prod.program);
                if (!programDate) return false;
                
                // Compare using getTime() for precise comparison
                return programDate.getTime() >= dateRange.start.getTime() && 
                       programDate.getTime() <= dateRange.end.getTime();
            });
        }
    }
    
    // Group and display
    displayProgramGroups(groupProgramsByDate(filtered));
}

  function displayProgramGroups(groups) {
    const container = document.getElementById('program-cards-container');
    if (!container) return;  // Safety check
    
    container.innerHTML = '';
    container.style.display = 'block';

    if (!groups.length) {
        container.innerHTML = `
            <div class="empty-state">
                <img src="icons/icon-192x192.png" alt="No programs found">
                <h6>No Programs Found</h6>
                <p>Try adjusting your filters to see more programs</p>
            </div>
        `;
        return;
    }

    // Count total programs across all groups
    const totalPrograms = groups.reduce((sum, group) => sum + group.products.length, 0);
    let programsShown = 0;
    let shouldAddLoadMore = false;

    // First, update the Applied Filters section
    updateAppliedFilters();

    groups.forEach(group => {
        // Skip this group if we've already shown enough programs
        if (programsShown >= displayLimit) {
            shouldAddLoadMore = true;
            return;
        }

        // Create date group container
        const dateGroup = document.createElement('div');
        dateGroup.className = 'date-group';
        
        // Create header with date and count
        const header = document.createElement('div');
        header.className = 'date-group-header';
        
        const dateTitle = document.createElement('h5');
        dateTitle.textContent = group.date.toLocaleDateString(undefined, {
            weekday: 'long',
            month: 'long',
            day: 'numeric'
        });
        
        const countBadge = document.createElement('span');
        countBadge.className = 'date-count-badge';
        countBadge.textContent = `${group.products.length} Program${group.products.length !== 1 ? 's' : ''}`;
        
        header.appendChild(dateTitle);
        header.appendChild(countBadge);
        dateGroup.appendChild(header);
        
        // Create program cards container
        const cardsRow = document.createElement('div');
        cardsRow.className = 'program-cards-row';
        
        // Sort products by start time before displaying
        const sortedProducts = [...group.products].sort((a, b) => {
            // Extract start times (assuming format "h:mm" or "hh:mm")
            const getStartTime = (program) => {
                const timeMatch = program.program.match(/\|\s*(\d{1,2}:\d{2}[ap]m)/i);
                if (!timeMatch) {
                    // For package format: (date range; start time - end time)
                    const packageMatch = program.program.match(/;\s*(\d{1,2}:\d{2}[ap]m)/i);
                    return packageMatch ? packageMatch[1] : "12:00am"; // fallback
                }
                return timeMatch[1];
            };

            // Convert time strings to comparable values (minutes since midnight)
            const convertTimeToMinutes = (timeStr) => {
                const [hourStr, minuteStr] = timeStr.replace(/[ap]m/i, '').split(':');
                let hours = parseInt(hourStr);
                const minutes = parseInt(minuteStr);
                if (timeStr.toLowerCase().includes('pm') && hours < 12) hours += 12;
                if (timeStr.toLowerCase().includes('am') && hours === 12) hours = 0;
                return hours * 60 + minutes;
            };

            const aTime = convertTimeToMinutes(getStartTime(a));
            const bTime = convertTimeToMinutes(getStartTime(b));
            return aTime - bTime;
        });
        
        // Only add programs up to the display limit
        const remainingSlots = displayLimit - programsShown;
        const productsToShow = sortedProducts.slice(0, remainingSlots);
        
        productsToShow.forEach(prod => {
            const cardDiv = createProgramCard(prod);
            cardsRow.appendChild(cardDiv);
            programsShown++;
        });

        // If we didn't show all programs in this group, we'll need the Load More button
        if (productsToShow.length < sortedProducts.length) {
            shouldAddLoadMore = true;
        }
        
        dateGroup.appendChild(cardsRow);
        container.appendChild(dateGroup);
    });

    // Add Load More button if there are more programs to show
    if (shouldAddLoadMore && programsShown < totalPrograms) {
        const loadMoreContainer = document.createElement('div');
        loadMoreContainer.className = 'text-center mt-4';
        
        const loadMoreBtn = document.createElement('button');
        loadMoreBtn.className = 'btn btn-outline-primary';
        loadMoreBtn.textContent = `Load More (${totalPrograms - programsShown} remaining)`;
        
        loadMoreBtn.addEventListener('click', () => {
            displayLimit += 10;
            renderFilteredPrograms();
        });
        
        loadMoreContainer.appendChild(loadMoreBtn);
        container.appendChild(loadMoreContainer);
    }
}

function updateAppliedFilters() {
    const container = document.getElementById('program-cards-container');
    if (!container) return;  // Safety check
    
    // Create Applied Filters section
    const appliedFiltersSection = document.createElement('div');
    appliedFiltersSection.className = 'mb-4';
    
    const activeFilters = [];
    
    // Check date filter
    const selectedDate = document.querySelector('.date-filter:checked');
    if (selectedDate) {
        let dateText = '';
        switch(selectedDate.value) {
            case 'today':
                dateText = 'Today';
                break;
            case 'tomorrow':
                dateText = 'Tomorrow';
                break;
            case 'thisWeek':
                dateText = 'This Week';
                break;
            case 'nextWeek':
                dateText = 'Next Week';
                break;
            case 'dateRange':
                const startDate = document.getElementById('date-range-start')?.value;
                const endDate = document.getElementById('date-range-end')?.value;
                if (startDate && endDate) {
                    dateText = `${new Date(startDate).toLocaleDateString()} - ${new Date(endDate).toLocaleDateString()}`;
                } else if (startDate) {
                    dateText = new Date(startDate).toLocaleDateString();
                }
                break;
        }
        if (dateText) {
            activeFilters.push({ type: 'Date', value: dateText });
        }
    }
    
    // Check level filters
    const selectedLevels = Array.from(document.querySelectorAll('.level-filter:checked'))
        .map(cb => cb.value);
    if (selectedLevels.length > 0) {
        activeFilters.push({ type: 'Level', value: selectedLevels.join(', ') });
    }
    
    // Check category filters
    const selectedCategories = Array.from(document.querySelectorAll('.category-filter:checked'))
        .map(cb => cb.value);
    if (selectedCategories.length > 0) {
        activeFilters.push({ type: 'Category', value: selectedCategories.join(', ') });
    }
    
    // Check packages filter
    if (showOnlyPackages) {
        activeFilters.push({ type: 'Special', value: 'Discounted Packages Only' });
    }
    
    // If no filters are applied, don't show the section
    if (activeFilters.length === 0) {
        return;
    }
    
    // Create the Applied Filters UI
    appliedFiltersSection.innerHTML = `
        <div class="card">
            <div class="card-body">
                <h6 class="mb-3"><i class="bi bi-funnel-fill"></i> Applied Filters</h6>
                <div class="d-flex flex-wrap gap-2">
                    ${activeFilters.map(filter => `
                        <span class="badge bg-primary">
                            ${filter.type}: ${filter.value}
                        </span>
                    `).join('')}
                </div>
            </div>
        </div>
    `;
    
    // Insert at the top of the container
    container.insertBefore(appliedFiltersSection, container.firstChild);
}

// Update renderFilteredPrograms to ensure programs are displayed
function renderFilteredPrograms() {
    const { selectedLevels, selectedCategories, selectedDate } = getSelectedFilters();
    
    // Filter products
    let filtered = allProducts;

    // Apply packages filter first if enabled
    if (showOnlyPackages) {
        filtered = filtered.filter(prod => prod.program.toLowerCase().includes('package'));
    }
    
    // Apply level filter
    if (selectedLevels.length > 0) {
        filtered = filtered.filter(prod => 
            prod.standardizedLevelList?.some(level => selectedLevels.includes(level))
        );
    }
    
    // Apply category filter
    if (selectedCategories.length > 0) {
        filtered = filtered.filter(prod => 
            selectedCategories.includes(prod.category)
        );
    }
    
    // Apply date filter
    if (selectedDate) {
        const dateRange = getDateRange(selectedDate);
        if (dateRange) {
            filtered = filtered.filter(prod => {
                const programDate = parseFirstDateFromProgram(prod.program);
                if (!programDate) return false;
                
                // Compare using getTime() for precise comparison
                return programDate.getTime() >= dateRange.start.getTime() && 
                       programDate.getTime() <= dateRange.end.getTime();
            });
        }
    }
    
    // Group and display - ensure this happens regardless of filter state
    const groupedPrograms = groupProgramsByDate(filtered);
    displayProgramGroups(groupedPrograms);
}

  function createProgramCard(prod) {
    const cardDiv = document.createElement('div');
    cardDiv.className = 'program-card';
    
    // Check if in cart
    const inCart = cartItems.some(ci => 
      ci.program === prod.program && ci.sessionId === selectedSession.spreadsheetId
    );
    if (inCart) {
      cardDiv.classList.add('added');
    }

    // Create header div to contain title and badges
    const headerDiv = document.createElement('div');
    headerDiv.className = 'program-header';

    const nameEl = document.createElement('div');
    nameEl.className = 'program-name';
    nameEl.textContent = prod.program;

    const badgesEl = document.createElement('div');
    badgesEl.className = 'badges';
    const catBadge = document.createElement('span');
    catBadge.className = 'badge bg-primary';
    catBadge.textContent = prod.category || 'N/A';

    const levelBadge = document.createElement('span');
    levelBadge.className = 'badge bg-info';
    levelBadge.textContent = prod.level || 'N/A';

    badgesEl.appendChild(catBadge);
    badgesEl.appendChild(levelBadge);

    if (prod.indoorOutdoor) {
      const ioBadge = document.createElement('span');
      ioBadge.className = 'badge bg-secondary';
      ioBadge.textContent = prod.indoorOutdoor;
      badgesEl.appendChild(ioBadge);
    }

    // Add name and badges to header
    headerDiv.appendChild(nameEl);
    headerDiv.appendChild(badgesEl);

    const priceEl = document.createElement('div');
    priceEl.className = 'program-price';

    // Calculate price with membership benefits
    let displayPrice = 0;
    if (inCart) {
      const cartItem = cartItems.find(ci => 
        ci.program === prod.program && ci.sessionId === selectedSession.spreadsheetId
      );
      displayPrice = cartItem.price;
    } else {
      const { total: readOnlyPrice } = getDiscountedPrice(
        prod,
        currentPlayer?.membershipType,
        currentPlayer?.membershipEndDate,
        currentPlayer?.membershipStartDate,
        freeSlotUsageMap,
        { readOnly: true }
      );
      displayPrice = readOnlyPrice;
    }

    const basePrice = prod.price || 0;
    let label = `$${displayPrice.toFixed(2)}`;
    let pct2 = 0;
    if (displayPrice < basePrice) {
      const catMap = discountMap[prod.category] || {};
      const discountFactor = catMap[currentPlayer?.membershipType] || 0;
      pct2 = Math.round(discountFactor * 100);
    }
    priceEl.textContent = label;

    // Create buttons container for proper ordering
    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'd-flex gap-2 align-items-center';

    // Create Add to Cart button first
    const addBtn = document.createElement('button');
    addBtn.className = 'btn btn-sm btn-success btn-add';
    if (displayPrice == 0) {
      addBtn.textContent = `Add to Cart (Free)`;
    } else if (nameEl.textContent.includes('Package') && displayPrice < basePrice){
      addBtn.textContent = `Add to Cart (Member Discount)`;
    } else if (nameEl.textContent.includes('Package')){
      addBtn.textContent = `Add to Cart`;
    } else if (pct2 > 0) {
      addBtn.textContent = `Add to Cart (${pct2}% Off)`;
    } else {
      addBtn.textContent = `Add to Cart`;
    }

    if (prod.soldOut) {
      addBtn.disabled = true;
      nameEl.innerHTML = `<s>${prod.program}</s> (Sold Out)`;
    }

    addBtn.addEventListener('click', () => {
      addProductToCart(prod);
      cardDiv.classList.add('added');
      // Hide extend membership button when adding to cart
      const extendBtn = cardDiv.querySelector('.btn-extend-membership');
      if (extendBtn) {
        extendBtn.style.display = 'none';
      }
      if (currentPlayer?.membershipType && prod.program.includes('Package')) {
        const allDates = parseAllDates(prod.program);
        if (allDates.length) {
          const membershipEnd = new Date(currentPlayer?.membershipEndDate || '');
          if (!isNaN(membershipEnd.getTime())) {
            const hasFullPriceDay = allDates.some(dateObj => dateObj > membershipEnd);
            if (hasFullPriceDay) {
              const alertModalEl = new bootstrap.Modal(document.getElementById('creditAlertModal'));
              alertModalEl.show();
            }
          }
        }
      }
    });

    buttonsContainer.appendChild(addBtn);

    // Create Extend Membership button after Add to Cart
    if (displayPrice == basePrice && currentPlayer?.membershipType && !inCart) {
      const extndBtn = document.createElement('button');
      extndBtn.className = 'btn btn-sm btn-danger btn-extend-membership';
      extndBtn.textContent = 'Extend Your Membership';
      extndBtn.addEventListener('click', () => {
        window.location.href = 'subscription.html';
      });
      buttonsContainer.appendChild(extndBtn);
    }

    const addedControls = document.createElement('div');
    addedControls.className = 'added-controls';
    addedControls.innerHTML = `
      <span class="text-success"><strong>&check;</strong> Added</span>
      <button class="btn btn-sm btn-outline-danger ms-2">Remove</button>
    `;
    const removeBtn = addedControls.querySelector('button');
    removeBtn.addEventListener('click', () => {
      removeProductFromCart(prod, selectedSession.spreadsheetId);
      cardDiv.classList.remove('added');
      
      // First check if an extend membership button already exists
      const existingExtendBtn = buttonsContainer.querySelector('.btn-extend-membership');
      
      // Only create and append a new button if one doesn't already exist
      if (!existingExtendBtn && displayPrice == basePrice && currentPlayer?.membershipType) {
        const extndBtn = document.createElement('button');
        extndBtn.className = 'btn btn-sm btn-danger btn-extend-membership';
        extndBtn.textContent = 'Extend Your Membership';
        extndBtn.addEventListener('click', () => {
          window.location.href = 'subscription.html';
        });
        buttonsContainer.appendChild(extndBtn);
      } else if (existingExtendBtn) {
        // If button exists, just make it visible again
        existingExtendBtn.style.display = '';
      }
    });

    cardDiv.appendChild(headerDiv);
    cardDiv.appendChild(priceEl);
    cardDiv.appendChild(buttonsContainer);
    cardDiv.appendChild(addedControls);

    return cardDiv;
}

  // ... existing code ...

  // Also update the session selection handler to use the new rendering
  function onSessionSelected(sessionObj) {
    selectedSession = sessionObj;
    allProducts = sessionObj.products || [];
    
    // Show filters and all programs immediately
    const filterSection = document.getElementById('filter-section');
    filterSection.style.display = 'block';
    
    // Reset display limit when changing sessions
    resetDisplayLimit();
    
    // Create filter checkboxes
    createFilterCheckboxes();
    
    // Display all programs grouped by date
    renderFilteredPrograms();
  }

  // Add a function to reset the display limit
  function resetDisplayLimit() {
    displayLimit = 30;
  }

 

  // Update clear filters to also reset packages toggle
  document.getElementById('clear-filters-btn')?.addEventListener('click', () => {
    // ... existing clear filter code ...
    
    // Reset packages toggle
    showOnlyPackages = false;
    const packagesBtn = document.getElementById('packages-toggle-btn');
    packagesBtn.classList.remove('btn-warning');
    packagesBtn.classList.add('btn-outline-warning');
    
    // Reset display limit
    resetDisplayLimit();
    
    // Re-render programs
    renderFilteredPrograms();
  });
</script>

<!-- Add this new modal structure before the closing body tag -->
<!-- Registration Success Modal -->
<div class="modal fade" id="registrationSuccessModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header bg-success text-white position-sticky top-0">
        <h5 class="modal-title">Registration Successful!</h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      
      <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
        <div class="alert alert-success mb-3">
          <p class="mb-1">Your registration has been submitted successfully!</p>
          <p class="mb-1" id="success-credit-message"></p>
          <p class="mb-0"><i>New registrations may take a couple minutes to appear under My Programs</i></p>
        </div>
        
        <h6 class="mb-3">Your Registered Programs:</h6>
        <div id="success-programs-list" class="list-group mb-3">
          <!-- Programs will be inserted here -->
        </div>
      </div>
      
      <div class="modal-footer position-sticky bottom-0 bg-white border-top">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<style>
/* Add these styles to your existing style section */
#registrationSuccessModal .modal-content {
  max-height: 90vh;
  display: flex;
  flex-direction: column;
}

#registrationSuccessModal .modal-header {
  z-index: 1;
}

#registrationSuccessModal .modal-body {
  flex: 1 1 auto;
  overflow-y: auto;
  scrollbar-width: thin;
}

#registrationSuccessModal .modal-footer {
  z-index: 1;
}

/* Optional: Style the scrollbar for webkit browsers */
#registrationSuccessModal .modal-body::-webkit-scrollbar {
  width: 6px;
}

#registrationSuccessModal .modal-body::-webkit-scrollbar-track {
  background: #f1f1f1;
}

#registrationSuccessModal .modal-body::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 3px;
}

#registrationSuccessModal .modal-body::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* Mobile-specific styles */
@media (max-width: 768px) {
  /* Remove padding from main containers */
  .container-fluid {
    padding-left: 0 !important;
    padding-right: 0 !important;
  }

  .row {
    margin-left: 0 !important;
    margin-right: 0 !important;
  }

  .col-12 {
    padding-left: 0 !important;
    padding-right: 0 !important;
  }

  /* Adjust card padding on mobile */
  .program-card {
    padding: 0.75rem;
    border-radius: 0;
    margin-bottom: 0.5rem;
    word-wrap: break-word;
    overflow-wrap: break-word;
  }

  .program-card .program-name {
    font-size: 0.95rem;
    line-height: 1.3;
    word-wrap: break-word;
    overflow-wrap: break-word;
    width: 100%;
  }

  /* Adjust date group styling on mobile */
  .date-group {
    border-radius: 0;
    padding: 1rem;
    margin-bottom: 1rem;
  }

  /* Adjust filter section on mobile */
  #filter-section .card {
    border-radius: 0;
    border-left: none;
    border-right: none;
  }

  /* Make badges more compact and wrap properly on mobile */
  .badge {
    font-size: 0.75rem;
    padding: 0.2rem 0.4rem;
    white-space: normal;
    text-align: left;
    height: auto;
    line-height: 1.2;
  }

  .program-card .badges {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    margin-top: 0.5rem;
  }

  /* Make price and buttons more compact */
  .program-price {
    font-size: 1rem;
    margin: 0.5rem 0;
  }

  .btn-add, .btn-extend-membership {
    font-size: 0.9rem;
    padding: 0.375rem 0.75rem;
  }

  /* Ensure filter section extends full width */
  #filter-section {
    margin-left: -15px;
    margin-right: -15px;
  }
}
</style>

<script>
// Add this new function to handle showing the success modal
function showSuccessModal(registeredPrograms, creditRemaining) {
  const modal = new bootstrap.Modal(document.getElementById('registrationSuccessModal'));
  const programsList = document.getElementById('success-programs-list');
  const creditMessage = document.getElementById('success-credit-message');
  
  // Clear previous content
  programsList.innerHTML = '';
  
  // Add each registered program
  registeredPrograms.forEach(program => {
    const programDiv = document.createElement('div');
    programDiv.className = 'list-group-item';
    
    // Format the title to include Category and Level
    const formattedTitle = `${program.category} ${program.level}: ${program.program}`;
    
    // Create program title and details
    const titleEl = document.createElement('h6');
    titleEl.className = 'mb-1';
    titleEl.textContent = formattedTitle;
    
    // Create session label
    const sessionEl = document.createElement('p');
    sessionEl.className = 'mb-2 text-muted small';
    sessionEl.textContent = program.sessionLabel;
    
    // Create calendar links container
    const linksDiv = document.createElement('div');
    linksDiv.className = 'd-flex gap-2';
    
    // Parse program date/time
    const parsedEvents = parseProgramString(program.program);
    if (parsedEvents && parsedEvents.length > 0) {
      const event = parsedEvents[0];
      
      // Set location based on session
      let location;
      if (program.sessionLabel.includes('Fair Lawn')) {
        location = "Montclair Pickleball Bergen County, 21-05 Morlot Ave., Fair Lawn, NJ";
      } else if (program.sessionLabel.includes('Caldwell')) {
        location = "Caldwell University";
      } else {
        // Default location as fallback
        location = "Montclair Pickleball Bergen County, 21-05 Morlot Ave., Fair Lawn, NJ";
      }
      
      // Use the same formatted title for calendar events
      const calendarTitle = formattedTitle;

      // Check if this is a package (has multiple weeks)
      const isPackage = program.program.toLowerCase().includes('package');
      let calendarOptions = {
        title: calendarTitle,
        startDate: new Date(event.start),
        endDate: new Date(event.end),
        details: `Category: ${program.category}\nLevel: ${program.level}`,
        location: location
      };

      // For packages, add recurrence information
      if (isPackage) {
        // Parse the package details
        const packageMatch = program.program.match(/(\d+)\s+Week.*\((\d{1,2}\/\d{1,2})\s*-\s*(\d{1,2}\/\d{1,2});\s*(\d{1,2}:\d{2}(?:am|pm))\s*-\s*(\d{1,2}:\d{2}(?:am|pm))\)/i);
        
        if (packageMatch) {
          const numWeeks = parseInt(packageMatch[1]);
          const startDateStr = packageMatch[2];
          const endDateStr = packageMatch[3];
          
          // Add recurrence info to calendar details
          calendarOptions.details += `\nThis is a ${numWeeks}-week package that repeats weekly.`;
          
          // For Google Calendar, we'll add RRULE
          const googleRrule = `RRULE:FREQ=WEEKLY;COUNT=${numWeeks}`;
          calendarOptions.googleRrule = googleRrule;
          
          // For Outlook, we'll specify the series end date
          const seriesEndDate = new Date(event.end);
          seriesEndDate.setDate(seriesEndDate.getDate() + (7 * (numWeeks - 1)));
          calendarOptions.outlookSeriesEndDate = seriesEndDate;
        }
      }
      
      // Google Calendar link
      const googleLink = document.createElement('a');
      googleLink.href = getGoogleCalendarUrl(calendarOptions);
      googleLink.className = 'btn btn-sm btn-outline-primary';
      googleLink.target = '_blank';
      googleLink.textContent = 'Add to Google Calendar';
      
      // Outlook Calendar link
      const outlookLink = document.createElement('a');
      outlookLink.href = getOutlookCalendarUrl(calendarOptions);
      outlookLink.className = 'btn btn-sm btn-outline-secondary';
      outlookLink.target = '_blank';
      outlookLink.textContent = 'Add to Outlook Calendar';
      
      linksDiv.appendChild(googleLink);
      linksDiv.appendChild(outlookLink);
    }
    
    // Assemble the program item
    programDiv.appendChild(titleEl);
    programDiv.appendChild(sessionEl);
    programDiv.appendChild(linksDiv);
    programsList.appendChild(programDiv);
  });
  
  // Update credit message if applicable
  if (creditRemaining > 0) {
    creditMessage.textContent = `You have $${creditRemaining.toFixed(2)} credit remaining.`;
  } else {
    creditMessage.textContent = '';
  }

  // Add event listener for when modal is hidden
  const modalElement = document.getElementById('registrationSuccessModal');
  modalElement.addEventListener('hidden.bs.modal', function () {
    // Re-render the programs to reset their state
    renderFilteredPrograms();
  }, { once: true }); // Use once: true so the listener is automatically removed after firing
  
  // Show the modal
  modal.show();
}

// ... existing code ...
</script>

</body>
</html>
